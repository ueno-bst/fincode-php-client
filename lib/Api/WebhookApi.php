<?php

declare(strict_types=1);
/**
 * fincode API.
 *
 * fincodeのAPIリファレンスです。\\ fincodeは決済情報のほか様々なリソースを管理できるため、リソース指向なREST APIをベースとしたインターフェイス設計のもとでAPIを提供しています。\\ APIの呼び出しにはAPIキーによる認証が必要であり、リクエストの際に`Authorization`ヘッダーに有効なAPIキーをセットすることで認証できます。
 *
 * The version of the OpenAPI document: 1.2.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Fincode\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Fincode\ApiException;
use OpenAPI\Fincode\Configuration;
use OpenAPI\Fincode\HeaderSelector;
use OpenAPI\Fincode\ObjectSerializer;

class WebhookApi
{
    /**
     * @var array<string, list<string>>
     */
    public const contentTypes = ['createWebhookSetting' => ['application/json'], 'deleteWebhookSetting' => ['application/json'], 'receiveWebhookOfApplePayPayment' => ['application/json'], 'receiveWebhookOfCard' => ['application/json'], 'receiveWebhookOfCardPayment' => ['application/json'], 'receiveWebhookOfCardPaymentBulkBatch' => ['application/json'], 'receiveWebhookOfCardRecurringBatch' => ['application/json'], 'receiveWebhookOfCardSubscription' => ['application/json'], 'receiveWebhookOfContract' => ['application/json'], 'receiveWebhookOfCustomerPaymentMethod' => ['application/json'], 'receiveWebhookOfDirectDebitPayment' => ['application/json'], 'receiveWebhookOfDirectDebitRecurringBatch' => ['application/json'], 'receiveWebhookOfDirectDebitSubscription' => ['application/json'], 'receiveWebhookOfKonbiniPayment' => ['application/json'], 'receiveWebhookOfPayPayPayment' => ['application/json'], 'receiveWebhookOfRegisteringCardPaymentBulk' => ['application/json'], 'receiveWebhookOfVirtualAccountPayment' => ['application/json'], 'retrieveWebhookSetting' => ['application/json'], 'retrieveWebhookSettingList' => ['application/json'], 'updateWebhookSetting' => ['application/json']];

    /**
     * @param int $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(private readonly ClientInterface $client = new Client(), private readonly Configuration $config = new Configuration(), private readonly HeaderSelector $headerSelector = new HeaderSelector(), private int $hostIndex = 0)
    {
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * createWebhookSetting: Webhook設定 登録.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上で発生したイベントを購読するWebhook設定を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingCreatingRequest $webhookSettingCreatingRequest webhookSettingCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createWebhookSetting'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookSettingCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createWebhookSetting(mixed $tenantShopId = null, mixed $webhookSettingCreatingRequest = null, string $contentType = self::contentTypes['createWebhookSetting'][0]): mixed
    {
        list($response) = $this->createWebhookSettingWithHttpInfo($tenantShopId, $webhookSettingCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createWebhookSettingWithHttpInfo: Webhook設定 登録.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上で発生したイベントを購読するWebhook設定を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingCreatingRequest $webhookSettingCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createWebhookSetting'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookSettingCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createWebhookSettingWithHttpInfo(mixed $tenantShopId = null, mixed $webhookSettingCreatingRequest = null, string $contentType = self::contentTypes['createWebhookSetting'][0]): array
    {
        $request = $this->createWebhookSettingRequest($tenantShopId, $webhookSettingCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createWebhookSettingAsync: Webhook設定 登録.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上で発生したイベントを購読するWebhook設定を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingCreatingRequest $webhookSettingCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createWebhookSettingAsync(mixed $tenantShopId = null, mixed $webhookSettingCreatingRequest = null, string $contentType = self::contentTypes['createWebhookSetting'][0]): PromiseInterface
    {
        return $this->createWebhookSettingAsyncWithHttpInfo($tenantShopId, $webhookSettingCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createWebhookSettingAsyncWithHttpInfo: Webhook設定 登録.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上で発生したイベントを購読するWebhook設定を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingCreatingRequest $webhookSettingCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createWebhookSettingAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $webhookSettingCreatingRequest = null, string $contentType = self::contentTypes['createWebhookSetting'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookSettingCreatingResponse';
        $request = $this->createWebhookSettingRequest($tenantShopId, $webhookSettingCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createWebhookSetting'.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上で発生したイベントを購読するWebhook設定を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingCreatingRequest $webhookSettingCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createWebhookSettingRequest(mixed $tenantShopId = null, mixed $webhookSettingCreatingRequest = null, string $contentType = self::contentTypes['createWebhookSetting'][0]): Request
    {
        $resourcePath = '/v1/webhook_settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookSettingCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookSettingCreatingRequest));
            } else {
                $httpBody = $webhookSettingCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deleteWebhookSetting: Webhook設定 削除.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteWebhookSetting'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookSettingDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteWebhookSetting(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteWebhookSetting'][0]): mixed
    {
        list($response) = $this->deleteWebhookSettingWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * deleteWebhookSettingWithHttpInfo: Webhook設定 削除.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteWebhookSetting'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookSettingDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteWebhookSettingWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteWebhookSetting'][0]): array
    {
        $request = $this->deleteWebhookSettingRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deleteWebhookSettingAsync: Webhook設定 削除.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteWebhookSettingAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteWebhookSetting'][0]): PromiseInterface
    {
        return $this->deleteWebhookSettingAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deleteWebhookSettingAsyncWithHttpInfo: Webhook設定 削除.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteWebhookSettingAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteWebhookSetting'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookSettingDeletingResponse';
        $request = $this->deleteWebhookSettingRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deleteWebhookSetting'.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteWebhookSettingRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteWebhookSetting'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deleteWebhookSetting');
        }
        $resourcePath = '/v1/webhook_settings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfApplePayPayment: Apple Pay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentApplePay $webhookEventPaymentApplePay webhookEventPaymentApplePay (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfApplePayPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfApplePayPayment(mixed $webhookEventPaymentApplePay = null, string $contentType = self::contentTypes['receiveWebhookOfApplePayPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfApplePayPaymentWithHttpInfo($webhookEventPaymentApplePay, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfApplePayPaymentWithHttpInfo: Apple Pay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentApplePay $webhookEventPaymentApplePay (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfApplePayPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfApplePayPaymentWithHttpInfo(mixed $webhookEventPaymentApplePay = null, string $contentType = self::contentTypes['receiveWebhookOfApplePayPayment'][0]): array
    {
        $request = $this->receiveWebhookOfApplePayPaymentRequest($webhookEventPaymentApplePay, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfApplePayPaymentAsync: Apple Pay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentApplePay $webhookEventPaymentApplePay (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfApplePayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfApplePayPaymentAsync(mixed $webhookEventPaymentApplePay = null, string $contentType = self::contentTypes['receiveWebhookOfApplePayPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfApplePayPaymentAsyncWithHttpInfo($webhookEventPaymentApplePay, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfApplePayPaymentAsyncWithHttpInfo: Apple Pay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentApplePay $webhookEventPaymentApplePay (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfApplePayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfApplePayPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentApplePay = null, string $contentType = self::contentTypes['receiveWebhookOfApplePayPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfApplePayPaymentRequest($webhookEventPaymentApplePay, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfApplePayPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentApplePay $webhookEventPaymentApplePay (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfApplePayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfApplePayPaymentRequest(mixed $webhookEventPaymentApplePay = null, string $contentType = self::contentTypes['receiveWebhookOfApplePayPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-applepay-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentApplePay)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentApplePay));
            } else {
                $httpBody = $webhookEventPaymentApplePay;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCard: カード.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCard $webhookEventCard webhookEventCard (optional)
     * @param string                                  $contentType      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCard'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCard(mixed $webhookEventCard = null, string $contentType = self::contentTypes['receiveWebhookOfCard'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCardWithHttpInfo($webhookEventCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCardWithHttpInfo: カード.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCard $webhookEventCard (optional)
     * @param string                                  $contentType      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCard'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardWithHttpInfo(mixed $webhookEventCard = null, string $contentType = self::contentTypes['receiveWebhookOfCard'][0]): array
    {
        $request = $this->receiveWebhookOfCardRequest($webhookEventCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCardAsync: カード.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCard $webhookEventCard (optional)
     * @param string                                  $contentType      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardAsync(mixed $webhookEventCard = null, string $contentType = self::contentTypes['receiveWebhookOfCard'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCardAsyncWithHttpInfo($webhookEventCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCardAsyncWithHttpInfo: カード.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCard $webhookEventCard (optional)
     * @param string                                  $contentType      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardAsyncWithHttpInfo(mixed $webhookEventCard = null, string $contentType = self::contentTypes['receiveWebhookOfCard'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCardRequest($webhookEventCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCard'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCard $webhookEventCard (optional)
     * @param string                                  $contentType      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRequest(mixed $webhookEventCard = null, string $contentType = self::contentTypes['receiveWebhookOfCard'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventCard));
            } else {
                $httpBody = $webhookEventCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCardPayment: カード決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentCard $webhookEventPaymentCard webhookEventPaymentCard (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPayment(mixed $webhookEventPaymentCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCardPaymentWithHttpInfo($webhookEventPaymentCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCardPaymentWithHttpInfo: カード決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentCard $webhookEventPaymentCard (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentWithHttpInfo(mixed $webhookEventPaymentCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPayment'][0]): array
    {
        $request = $this->receiveWebhookOfCardPaymentRequest($webhookEventPaymentCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCardPaymentAsync: カード決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentCard $webhookEventPaymentCard (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentAsync(mixed $webhookEventPaymentCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCardPaymentAsyncWithHttpInfo($webhookEventPaymentCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCardPaymentAsyncWithHttpInfo: カード決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentCard $webhookEventPaymentCard (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCardPaymentRequest($webhookEventPaymentCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCardPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentCard $webhookEventPaymentCard (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentRequest(mixed $webhookEventPaymentCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentCard));
            } else {
                $httpBody = $webhookEventPaymentCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCardPaymentBulkBatch: 一括決済課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkBatchCard $webhookEventPaymentBulkBatchCard webhookEventPaymentBulkBatchCard (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentBulkBatch(mixed $webhookEventPaymentBulkBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCardPaymentBulkBatchWithHttpInfo($webhookEventPaymentBulkBatchCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCardPaymentBulkBatchWithHttpInfo: 一括決済課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkBatchCard $webhookEventPaymentBulkBatchCard (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentBulkBatchWithHttpInfo(mixed $webhookEventPaymentBulkBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'][0]): array
    {
        $request = $this->receiveWebhookOfCardPaymentBulkBatchRequest($webhookEventPaymentBulkBatchCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCardPaymentBulkBatchAsync: 一括決済課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkBatchCard $webhookEventPaymentBulkBatchCard (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentBulkBatchAsync(mixed $webhookEventPaymentBulkBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCardPaymentBulkBatchAsyncWithHttpInfo($webhookEventPaymentBulkBatchCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCardPaymentBulkBatchAsyncWithHttpInfo: 一括決済課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkBatchCard $webhookEventPaymentBulkBatchCard (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentBulkBatchAsyncWithHttpInfo(mixed $webhookEventPaymentBulkBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCardPaymentBulkBatchRequest($webhookEventPaymentBulkBatchCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCardPaymentBulkBatch'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkBatchCard $webhookEventPaymentBulkBatchCard (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardPaymentBulkBatchRequest(mixed $webhookEventPaymentBulkBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardPaymentBulkBatch'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card-payment-bulk-batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentBulkBatchCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentBulkBatchCard));
            } else {
                $httpBody = $webhookEventPaymentBulkBatchCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCardRecurringBatch: サブスクリプション課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchCard $webhookEventRecurringBatchCard webhookEventRecurringBatchCard (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardRecurringBatch'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRecurringBatch(mixed $webhookEventRecurringBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardRecurringBatch'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCardRecurringBatchWithHttpInfo($webhookEventRecurringBatchCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCardRecurringBatchWithHttpInfo: サブスクリプション課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchCard $webhookEventRecurringBatchCard (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardRecurringBatch'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRecurringBatchWithHttpInfo(mixed $webhookEventRecurringBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardRecurringBatch'][0]): array
    {
        $request = $this->receiveWebhookOfCardRecurringBatchRequest($webhookEventRecurringBatchCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCardRecurringBatchAsync: サブスクリプション課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchCard $webhookEventRecurringBatchCard (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRecurringBatchAsync(mixed $webhookEventRecurringBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardRecurringBatch'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCardRecurringBatchAsyncWithHttpInfo($webhookEventRecurringBatchCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCardRecurringBatchAsyncWithHttpInfo: サブスクリプション課金（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchCard $webhookEventRecurringBatchCard (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRecurringBatchAsyncWithHttpInfo(mixed $webhookEventRecurringBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardRecurringBatch'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCardRecurringBatchRequest($webhookEventRecurringBatchCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCardRecurringBatch'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchCard $webhookEventRecurringBatchCard (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardRecurringBatchRequest(mixed $webhookEventRecurringBatchCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardRecurringBatch'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card-recurring-batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventRecurringBatchCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventRecurringBatchCard));
            } else {
                $httpBody = $webhookEventRecurringBatchCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCardSubscription: サブスクリプション（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionCard $webhookEventSubscriptionCard webhookEventSubscriptionCard (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardSubscription(mixed $webhookEventSubscriptionCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardSubscription'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCardSubscriptionWithHttpInfo($webhookEventSubscriptionCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCardSubscriptionWithHttpInfo: サブスクリプション（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionCard $webhookEventSubscriptionCard (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardSubscriptionWithHttpInfo(mixed $webhookEventSubscriptionCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardSubscription'][0]): array
    {
        $request = $this->receiveWebhookOfCardSubscriptionRequest($webhookEventSubscriptionCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCardSubscriptionAsync: サブスクリプション（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionCard $webhookEventSubscriptionCard (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardSubscriptionAsync(mixed $webhookEventSubscriptionCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardSubscription'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCardSubscriptionAsyncWithHttpInfo($webhookEventSubscriptionCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCardSubscriptionAsyncWithHttpInfo: サブスクリプション（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionCard $webhookEventSubscriptionCard (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardSubscriptionAsyncWithHttpInfo(mixed $webhookEventSubscriptionCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCardSubscriptionRequest($webhookEventSubscriptionCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCardSubscription'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionCard $webhookEventSubscriptionCard (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCardSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCardSubscriptionRequest(mixed $webhookEventSubscriptionCard = null, string $contentType = self::contentTypes['receiveWebhookOfCardSubscription'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card-subscription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventSubscriptionCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventSubscriptionCard));
            } else {
                $httpBody = $webhookEventSubscriptionCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfContract: 決済手段 契約状況
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventContract $webhookEventContract webhookEventContract (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfContract'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfContract(mixed $webhookEventContract = null, string $contentType = self::contentTypes['receiveWebhookOfContract'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfContractWithHttpInfo($webhookEventContract, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfContractWithHttpInfo: 決済手段 契約状況
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventContract $webhookEventContract (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfContract'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfContractWithHttpInfo(mixed $webhookEventContract = null, string $contentType = self::contentTypes['receiveWebhookOfContract'][0]): array
    {
        $request = $this->receiveWebhookOfContractRequest($webhookEventContract, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfContractAsync: 決済手段 契約状況
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventContract $webhookEventContract (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfContractAsync(mixed $webhookEventContract = null, string $contentType = self::contentTypes['receiveWebhookOfContract'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfContractAsyncWithHttpInfo($webhookEventContract, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfContractAsyncWithHttpInfo: 決済手段 契約状況
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventContract $webhookEventContract (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfContractAsyncWithHttpInfo(mixed $webhookEventContract = null, string $contentType = self::contentTypes['receiveWebhookOfContract'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfContractRequest($webhookEventContract, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfContract'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventContract $webhookEventContract (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfContractRequest(mixed $webhookEventContract = null, string $contentType = self::contentTypes['receiveWebhookOfContract'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-contract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventContract)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventContract));
            } else {
                $httpBody = $webhookEventContract;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfCustomerPaymentMethod: 決済手段.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCustomerPaymentMethod $webhookEventCustomerPaymentMethod webhookEventCustomerPaymentMethod (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCustomerPaymentMethod(mixed $webhookEventCustomerPaymentMethod = null, string $contentType = self::contentTypes['receiveWebhookOfCustomerPaymentMethod'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfCustomerPaymentMethodWithHttpInfo($webhookEventCustomerPaymentMethod, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfCustomerPaymentMethodWithHttpInfo: 決済手段.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCustomerPaymentMethod $webhookEventCustomerPaymentMethod (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCustomerPaymentMethodWithHttpInfo(mixed $webhookEventCustomerPaymentMethod = null, string $contentType = self::contentTypes['receiveWebhookOfCustomerPaymentMethod'][0]): array
    {
        $request = $this->receiveWebhookOfCustomerPaymentMethodRequest($webhookEventCustomerPaymentMethod, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfCustomerPaymentMethodAsync: 決済手段.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCustomerPaymentMethod $webhookEventCustomerPaymentMethod (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCustomerPaymentMethodAsync(mixed $webhookEventCustomerPaymentMethod = null, string $contentType = self::contentTypes['receiveWebhookOfCustomerPaymentMethod'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfCustomerPaymentMethodAsyncWithHttpInfo($webhookEventCustomerPaymentMethod, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfCustomerPaymentMethodAsyncWithHttpInfo: 決済手段.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCustomerPaymentMethod $webhookEventCustomerPaymentMethod (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCustomerPaymentMethodAsyncWithHttpInfo(mixed $webhookEventCustomerPaymentMethod = null, string $contentType = self::contentTypes['receiveWebhookOfCustomerPaymentMethod'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfCustomerPaymentMethodRequest($webhookEventCustomerPaymentMethod, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfCustomerPaymentMethod'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventCustomerPaymentMethod $webhookEventCustomerPaymentMethod (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfCustomerPaymentMethodRequest(mixed $webhookEventCustomerPaymentMethod = null, string $contentType = self::contentTypes['receiveWebhookOfCustomerPaymentMethod'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-customer-payment_method';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventCustomerPaymentMethod)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventCustomerPaymentMethod));
            } else {
                $httpBody = $webhookEventCustomerPaymentMethod;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfDirectDebitPayment: 口座振替
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentDirectDebit $webhookEventPaymentDirectDebit webhookEventPaymentDirectDebit (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitPayment(mixed $webhookEventPaymentDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfDirectDebitPaymentWithHttpInfo($webhookEventPaymentDirectDebit, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfDirectDebitPaymentWithHttpInfo: 口座振替
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentDirectDebit $webhookEventPaymentDirectDebit (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitPaymentWithHttpInfo(mixed $webhookEventPaymentDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitPayment'][0]): array
    {
        $request = $this->receiveWebhookOfDirectDebitPaymentRequest($webhookEventPaymentDirectDebit, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfDirectDebitPaymentAsync: 口座振替
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentDirectDebit $webhookEventPaymentDirectDebit (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitPaymentAsync(mixed $webhookEventPaymentDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfDirectDebitPaymentAsyncWithHttpInfo($webhookEventPaymentDirectDebit, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfDirectDebitPaymentAsyncWithHttpInfo: 口座振替
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentDirectDebit $webhookEventPaymentDirectDebit (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfDirectDebitPaymentRequest($webhookEventPaymentDirectDebit, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfDirectDebitPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentDirectDebit $webhookEventPaymentDirectDebit (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitPaymentRequest(mixed $webhookEventPaymentDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-directdebit-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentDirectDebit)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentDirectDebit));
            } else {
                $httpBody = $webhookEventPaymentDirectDebit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfDirectDebitRecurringBatch: サブスクリプション課金（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchDirectDebit $webhookEventRecurringBatchDirectDebit webhookEventRecurringBatchDirectDebit (optional)
     * @param string                                                       $contentType                           The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitRecurringBatch(mixed $webhookEventRecurringBatchDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfDirectDebitRecurringBatchWithHttpInfo($webhookEventRecurringBatchDirectDebit, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfDirectDebitRecurringBatchWithHttpInfo: サブスクリプション課金（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchDirectDebit $webhookEventRecurringBatchDirectDebit (optional)
     * @param string                                                       $contentType                           The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitRecurringBatchWithHttpInfo(mixed $webhookEventRecurringBatchDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'][0]): array
    {
        $request = $this->receiveWebhookOfDirectDebitRecurringBatchRequest($webhookEventRecurringBatchDirectDebit, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfDirectDebitRecurringBatchAsync: サブスクリプション課金（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchDirectDebit $webhookEventRecurringBatchDirectDebit (optional)
     * @param string                                                       $contentType                           The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitRecurringBatchAsync(mixed $webhookEventRecurringBatchDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfDirectDebitRecurringBatchAsyncWithHttpInfo($webhookEventRecurringBatchDirectDebit, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfDirectDebitRecurringBatchAsyncWithHttpInfo: サブスクリプション課金（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchDirectDebit $webhookEventRecurringBatchDirectDebit (optional)
     * @param string                                                       $contentType                           The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitRecurringBatchAsyncWithHttpInfo(mixed $webhookEventRecurringBatchDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfDirectDebitRecurringBatchRequest($webhookEventRecurringBatchDirectDebit, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfDirectDebitRecurringBatch'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventRecurringBatchDirectDebit $webhookEventRecurringBatchDirectDebit (optional)
     * @param string                                                       $contentType                           The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitRecurringBatchRequest(mixed $webhookEventRecurringBatchDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitRecurringBatch'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-directdebit-recurring-batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventRecurringBatchDirectDebit)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventRecurringBatchDirectDebit));
            } else {
                $httpBody = $webhookEventRecurringBatchDirectDebit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfDirectDebitSubscription: サブスクリプション（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionDirectDebit $webhookEventSubscriptionDirectDebit webhookEventSubscriptionDirectDebit (optional)
     * @param string                                                     $contentType                         The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitSubscription(mixed $webhookEventSubscriptionDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitSubscription'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfDirectDebitSubscriptionWithHttpInfo($webhookEventSubscriptionDirectDebit, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfDirectDebitSubscriptionWithHttpInfo: サブスクリプション（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionDirectDebit $webhookEventSubscriptionDirectDebit (optional)
     * @param string                                                     $contentType                         The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitSubscriptionWithHttpInfo(mixed $webhookEventSubscriptionDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitSubscription'][0]): array
    {
        $request = $this->receiveWebhookOfDirectDebitSubscriptionRequest($webhookEventSubscriptionDirectDebit, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfDirectDebitSubscriptionAsync: サブスクリプション（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionDirectDebit $webhookEventSubscriptionDirectDebit (optional)
     * @param string                                                     $contentType                         The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitSubscriptionAsync(mixed $webhookEventSubscriptionDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitSubscription'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfDirectDebitSubscriptionAsyncWithHttpInfo($webhookEventSubscriptionDirectDebit, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfDirectDebitSubscriptionAsyncWithHttpInfo: サブスクリプション（口座振替）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionDirectDebit $webhookEventSubscriptionDirectDebit (optional)
     * @param string                                                     $contentType                         The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitSubscriptionAsyncWithHttpInfo(mixed $webhookEventSubscriptionDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfDirectDebitSubscriptionRequest($webhookEventSubscriptionDirectDebit, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfDirectDebitSubscription'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventSubscriptionDirectDebit $webhookEventSubscriptionDirectDebit (optional)
     * @param string                                                     $contentType                         The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfDirectDebitSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfDirectDebitSubscriptionRequest(mixed $webhookEventSubscriptionDirectDebit = null, string $contentType = self::contentTypes['receiveWebhookOfDirectDebitSubscription'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-directdebit-subscription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventSubscriptionDirectDebit)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventSubscriptionDirectDebit));
            } else {
                $httpBody = $webhookEventSubscriptionDirectDebit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfKonbiniPayment: コンビニ決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentKonbini $webhookEventPaymentKonbini webhookEventPaymentKonbini (optional)
     * @param string                                            $contentType                The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfKonbiniPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfKonbiniPayment(mixed $webhookEventPaymentKonbini = null, string $contentType = self::contentTypes['receiveWebhookOfKonbiniPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfKonbiniPaymentWithHttpInfo($webhookEventPaymentKonbini, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfKonbiniPaymentWithHttpInfo: コンビニ決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentKonbini $webhookEventPaymentKonbini (optional)
     * @param string                                            $contentType                The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfKonbiniPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfKonbiniPaymentWithHttpInfo(mixed $webhookEventPaymentKonbini = null, string $contentType = self::contentTypes['receiveWebhookOfKonbiniPayment'][0]): array
    {
        $request = $this->receiveWebhookOfKonbiniPaymentRequest($webhookEventPaymentKonbini, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfKonbiniPaymentAsync: コンビニ決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentKonbini $webhookEventPaymentKonbini (optional)
     * @param string                                            $contentType                The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfKonbiniPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfKonbiniPaymentAsync(mixed $webhookEventPaymentKonbini = null, string $contentType = self::contentTypes['receiveWebhookOfKonbiniPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfKonbiniPaymentAsyncWithHttpInfo($webhookEventPaymentKonbini, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfKonbiniPaymentAsyncWithHttpInfo: コンビニ決済.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentKonbini $webhookEventPaymentKonbini (optional)
     * @param string                                            $contentType                The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfKonbiniPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfKonbiniPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentKonbini = null, string $contentType = self::contentTypes['receiveWebhookOfKonbiniPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfKonbiniPaymentRequest($webhookEventPaymentKonbini, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfKonbiniPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentKonbini $webhookEventPaymentKonbini (optional)
     * @param string                                            $contentType                The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfKonbiniPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfKonbiniPaymentRequest(mixed $webhookEventPaymentKonbini = null, string $contentType = self::contentTypes['receiveWebhookOfKonbiniPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-konbini-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentKonbini)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentKonbini));
            } else {
                $httpBody = $webhookEventPaymentKonbini;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfPayPayPayment: PayPay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentPayPay $webhookEventPaymentPayPay webhookEventPaymentPayPay (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfPayPayPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfPayPayPayment(mixed $webhookEventPaymentPayPay = null, string $contentType = self::contentTypes['receiveWebhookOfPayPayPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfPayPayPaymentWithHttpInfo($webhookEventPaymentPayPay, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfPayPayPaymentWithHttpInfo: PayPay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentPayPay $webhookEventPaymentPayPay (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfPayPayPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfPayPayPaymentWithHttpInfo(mixed $webhookEventPaymentPayPay = null, string $contentType = self::contentTypes['receiveWebhookOfPayPayPayment'][0]): array
    {
        $request = $this->receiveWebhookOfPayPayPaymentRequest($webhookEventPaymentPayPay, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfPayPayPaymentAsync: PayPay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentPayPay $webhookEventPaymentPayPay (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfPayPayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfPayPayPaymentAsync(mixed $webhookEventPaymentPayPay = null, string $contentType = self::contentTypes['receiveWebhookOfPayPayPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfPayPayPaymentAsyncWithHttpInfo($webhookEventPaymentPayPay, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfPayPayPaymentAsyncWithHttpInfo: PayPay.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentPayPay $webhookEventPaymentPayPay (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfPayPayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfPayPayPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentPayPay = null, string $contentType = self::contentTypes['receiveWebhookOfPayPayPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfPayPayPaymentRequest($webhookEventPaymentPayPay, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfPayPayPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentPayPay $webhookEventPaymentPayPay (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfPayPayPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfPayPayPaymentRequest(mixed $webhookEventPaymentPayPay = null, string $contentType = self::contentTypes['receiveWebhookOfPayPayPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-paypay-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentPayPay)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentPayPay));
            } else {
                $httpBody = $webhookEventPaymentPayPay;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfRegisteringCardPaymentBulk: 一括決済（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkRegistCard $webhookEventPaymentBulkRegistCard webhookEventPaymentBulkRegistCard (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfRegisteringCardPaymentBulk(mixed $webhookEventPaymentBulkRegistCard = null, string $contentType = self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfRegisteringCardPaymentBulkWithHttpInfo($webhookEventPaymentBulkRegistCard, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfRegisteringCardPaymentBulkWithHttpInfo: 一括決済（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkRegistCard $webhookEventPaymentBulkRegistCard (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfRegisteringCardPaymentBulkWithHttpInfo(mixed $webhookEventPaymentBulkRegistCard = null, string $contentType = self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'][0]): array
    {
        $request = $this->receiveWebhookOfRegisteringCardPaymentBulkRequest($webhookEventPaymentBulkRegistCard, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfRegisteringCardPaymentBulkAsync: 一括決済（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkRegistCard $webhookEventPaymentBulkRegistCard (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfRegisteringCardPaymentBulkAsync(mixed $webhookEventPaymentBulkRegistCard = null, string $contentType = self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfRegisteringCardPaymentBulkAsyncWithHttpInfo($webhookEventPaymentBulkRegistCard, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfRegisteringCardPaymentBulkAsyncWithHttpInfo: 一括決済（カード決済）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkRegistCard $webhookEventPaymentBulkRegistCard (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfRegisteringCardPaymentBulkAsyncWithHttpInfo(mixed $webhookEventPaymentBulkRegistCard = null, string $contentType = self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfRegisteringCardPaymentBulkRequest($webhookEventPaymentBulkRegistCard, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfRegisteringCardPaymentBulk'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentBulkRegistCard $webhookEventPaymentBulkRegistCard (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfRegisteringCardPaymentBulkRequest(mixed $webhookEventPaymentBulkRegistCard = null, string $contentType = self::contentTypes['receiveWebhookOfRegisteringCardPaymentBulk'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-card-payment-bulk-regist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentBulkRegistCard)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentBulkRegistCard));
            } else {
                $httpBody = $webhookEventPaymentBulkRegistCard;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * receiveWebhookOfVirtualAccountPayment: 銀行振込（バーチャル口座）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentVirtualAccount $webhookEventPaymentVirtualAccount webhookEventPaymentVirtualAccount (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfVirtualAccountPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfVirtualAccountPayment(mixed $webhookEventPaymentVirtualAccount = null, string $contentType = self::contentTypes['receiveWebhookOfVirtualAccountPayment'][0]): mixed
    {
        list($response) = $this->receiveWebhookOfVirtualAccountPaymentWithHttpInfo($webhookEventPaymentVirtualAccount, $contentType);

        return $response;
    }

    /**
     * receiveWebhookOfVirtualAccountPaymentWithHttpInfo: 銀行振込（バーチャル口座）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentVirtualAccount $webhookEventPaymentVirtualAccount (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfVirtualAccountPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfVirtualAccountPaymentWithHttpInfo(mixed $webhookEventPaymentVirtualAccount = null, string $contentType = self::contentTypes['receiveWebhookOfVirtualAccountPayment'][0]): array
    {
        $request = $this->receiveWebhookOfVirtualAccountPaymentRequest($webhookEventPaymentVirtualAccount, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * receiveWebhookOfVirtualAccountPaymentAsync: 銀行振込（バーチャル口座）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentVirtualAccount $webhookEventPaymentVirtualAccount (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfVirtualAccountPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfVirtualAccountPaymentAsync(mixed $webhookEventPaymentVirtualAccount = null, string $contentType = self::contentTypes['receiveWebhookOfVirtualAccountPayment'][0]): PromiseInterface
    {
        return $this->receiveWebhookOfVirtualAccountPaymentAsyncWithHttpInfo($webhookEventPaymentVirtualAccount, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * receiveWebhookOfVirtualAccountPaymentAsyncWithHttpInfo: 銀行振込（バーチャル口座）.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentVirtualAccount $webhookEventPaymentVirtualAccount (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfVirtualAccountPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfVirtualAccountPaymentAsyncWithHttpInfo(mixed $webhookEventPaymentVirtualAccount = null, string $contentType = self::contentTypes['receiveWebhookOfVirtualAccountPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookResponse';
        $request = $this->receiveWebhookOfVirtualAccountPaymentRequest($webhookEventPaymentVirtualAccount, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'receiveWebhookOfVirtualAccountPayment'.
     *
     * @param \OpenAPI\Fincode\Model\WebhookEventPaymentVirtualAccount $webhookEventPaymentVirtualAccount (optional)
     * @param string                                                   $contentType                       The value for the Content-Type header. Check self::contentTypes['receiveWebhookOfVirtualAccountPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function receiveWebhookOfVirtualAccountPaymentRequest(mixed $webhookEventPaymentVirtualAccount = null, string $contentType = self::contentTypes['receiveWebhookOfVirtualAccountPayment'][0]): Request
    {
        $resourcePath = '/your-endpoint-on-virtualaccount-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json', 'text/plain'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookEventPaymentVirtualAccount)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookEventPaymentVirtualAccount));
            } else {
                $httpBody = $webhookEventPaymentVirtualAccount;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveWebhookSetting: Webhook設定 取得.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSetting'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSetting(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSetting'][0]): mixed
    {
        list($response) = $this->retrieveWebhookSettingWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveWebhookSettingWithHttpInfo: Webhook設定 取得.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSetting'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSetting'][0]): array
    {
        $request = $this->retrieveWebhookSettingRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveWebhookSettingAsync: Webhook設定 取得.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSetting'][0]): PromiseInterface
    {
        return $this->retrieveWebhookSettingAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveWebhookSettingAsyncWithHttpInfo: Webhook設定 取得.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSetting'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookSettingRetrievingResponse';
        $request = $this->retrieveWebhookSettingRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveWebhookSetting'.
     *
     * @param string $id           Webhook設定のID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSetting'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveWebhookSetting');
        }
        $resourcePath = '/v1/webhook_settings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveWebhookSettingList: Webhook設定 一覧取得.
     *
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定から一覧で取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSettingList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingList(mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSettingList'][0]): mixed
    {
        list($response) = $this->retrieveWebhookSettingListWithHttpInfo($tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveWebhookSettingListWithHttpInfo: Webhook設定 一覧取得.
     *
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定から一覧で取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSettingList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingListWithHttpInfo(mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSettingList'][0]): array
    {
        $request = $this->retrieveWebhookSettingListRequest($tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveWebhookSettingListAsync: Webhook設定 一覧取得.
     *
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定から一覧で取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSettingList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingListAsync(mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSettingList'][0]): PromiseInterface
    {
        return $this->retrieveWebhookSettingListAsyncWithHttpInfo($tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveWebhookSettingListAsyncWithHttpInfo: Webhook設定 一覧取得.
     *
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定から一覧で取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSettingList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingListAsyncWithHttpInfo(mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSettingList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookSettingListRetrievingResponse';
        $request = $this->retrieveWebhookSettingListRequest($tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveWebhookSettingList'.
     *
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定から一覧で取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveWebhookSettingList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveWebhookSettingListRequest(mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveWebhookSettingList'][0]): Request
    {
        $resourcePath = '/v1/webhook_settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateWebhookSetting: Webhook設定 更新.
     *
     * @param string                                               $id                            Webhook設定のID (required)
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingUpdatingRequest $webhookSettingUpdatingRequest webhookSettingUpdatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['updateWebhookSetting'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateWebhookSetting(mixed $id, mixed $tenantShopId = null, mixed $webhookSettingUpdatingRequest = null, string $contentType = self::contentTypes['updateWebhookSetting'][0]): mixed
    {
        list($response) = $this->updateWebhookSettingWithHttpInfo($id, $tenantShopId, $webhookSettingUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateWebhookSettingWithHttpInfo: Webhook設定 更新.
     *
     * @param string                                               $id                            Webhook設定のID (required)
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingUpdatingRequest $webhookSettingUpdatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['updateWebhookSetting'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateWebhookSettingWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $webhookSettingUpdatingRequest = null, string $contentType = self::contentTypes['updateWebhookSetting'][0]): array
    {
        $request = $this->updateWebhookSettingRequest($id, $tenantShopId, $webhookSettingUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateWebhookSettingAsync: Webhook設定 更新.
     *
     * @param string                                               $id                            Webhook設定のID (required)
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingUpdatingRequest $webhookSettingUpdatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['updateWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateWebhookSettingAsync(mixed $id, mixed $tenantShopId = null, mixed $webhookSettingUpdatingRequest = null, string $contentType = self::contentTypes['updateWebhookSetting'][0]): PromiseInterface
    {
        return $this->updateWebhookSettingAsyncWithHttpInfo($id, $tenantShopId, $webhookSettingUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateWebhookSettingAsyncWithHttpInfo: Webhook設定 更新.
     *
     * @param string                                               $id                            Webhook設定のID (required)
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingUpdatingRequest $webhookSettingUpdatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['updateWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateWebhookSettingAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $webhookSettingUpdatingRequest = null, string $contentType = self::contentTypes['updateWebhookSetting'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\WebhookSettingUpdatingResponse';
        $request = $this->updateWebhookSettingRequest($id, $tenantShopId, $webhookSettingUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateWebhookSetting'.
     *
     * @param string                                               $id                            Webhook設定のID (required)
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づくWebhook設定のうち、指定したIDのWebhook設定を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\WebhookSettingUpdatingRequest $webhookSettingUpdatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['updateWebhookSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateWebhookSettingRequest(mixed $id, mixed $tenantShopId = null, mixed $webhookSettingUpdatingRequest = null, string $contentType = self::contentTypes['updateWebhookSetting'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateWebhookSetting');
        }
        $resourcePath = '/v1/webhook_settings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($webhookSettingUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhookSettingUpdatingRequest));
            } else {
                $httpBody = $webhookSettingUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * Create http client option.
     *
     * @return array of http client options
     *
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
