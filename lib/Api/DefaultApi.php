<?php

declare(strict_types=1);
/**
 * fincode API.
 *
 * fincodeのAPIリファレンスです。\\ fincodeは決済情報のほか様々なリソースを管理できるため、リソース指向なREST APIをベースとしたインターフェイス設計のもとでAPIを提供しています。\\ APIの呼び出しにはAPIキーによる認証が必要であり、リクエストの際に`Authorization`ヘッダーに有効なAPIキーをセットすることで認証できます。
 *
 * The version of the OpenAPI document: 1.2.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Fincode\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Fincode\ApiException;
use OpenAPI\Fincode\Configuration;
use OpenAPI\Fincode\HeaderSelector;
use OpenAPI\Fincode\ObjectSerializer;

class DefaultApi
{
    /**
     * @var array<string, list<string>>
     */
    public const contentTypes = ['authorizePayment' => ['application/json'], 'cancelPayment' => ['application/json'], 'capturePayment' => ['application/json'], 'changeAmountOfPayment' => ['application/json'], 'createCardRegistrationSession' => ['application/json'], 'createCustomer' => ['application/json'], 'createCustomerCard' => ['application/json'], 'createCustomerPaymentMethod' => ['application/json'], 'createPayment' => ['application/json'], 'createPaymentBulk' => ['multipart/form-data'], 'createPaymentSession' => ['application/json'], 'createPlan' => ['application/json'], 'createSubscription' => ['application/json'], 'createTenantWithExistingUser' => ['application/json'], 'createTenantWithNewUser' => ['application/json'], 'deleteCustomer' => ['application/json'], 'deleteCustomerCard' => ['application/json'], 'deleteCustomerPaymentMethod' => ['application/json'], 'deletePaymentBulk' => ['application/json'], 'deletePlan' => ['application/json'], 'executePayment' => ['application/json'], 'executePaymentAfterThreeDSecureecure' => ['application/json'], 'generateBarcodeOfPayment' => ['application/json'], 'requestProductionEnvironment' => ['multipart/form-data'], 'reserveProvider' => ['multipart/form-data'], 'retrieveAccount' => ['application/json'], 'retrieveAccountDetailList' => ['application/json'], 'retrieveAccountList' => ['application/json'], 'retrieveCustomer' => ['application/json'], 'retrieveCustomerCard' => ['application/json'], 'retrieveCustomerCardList' => ['application/json'], 'retrieveCustomerList' => ['application/json'], 'retrieveCustomerPaymentMethod' => ['application/json'], 'retrieveCustomerPaymentMethodList' => ['application/json'], 'retrievePayment' => ['application/json'], 'retrievePaymentBulkDetailList' => ['application/json'], 'retrievePaymentBulkList' => ['application/json'], 'retrievePaymentList' => ['application/json'], 'retrievePlan' => ['application/json'], 'retrievePlanList' => ['application/json'], 'retrievePlatformAccount' => ['application/json'], 'retrievePlatformAccountList' => ['application/json'], 'retrievePlatformAccountSummaryList' => ['application/json'], 'retrievePlatformShop' => ['application/json'], 'retrievePlatformShopList' => ['application/json'], 'retrieveSubscription' => ['application/json'], 'retrieveSubscriptionList' => ['application/json'], 'retrieveSubscriptionResultList' => ['application/json'], 'retrieveTenantContract' => ['application/json'], 'retrieveTenantExaminationInfo' => ['application/json'], 'retrieveTenantExaminationInfoV2' => ['application/json'], 'retrieveTenantShop' => ['application/json'], 'retrieveTenantShopList' => ['application/json'], 'unsubscripbeSubscription' => ['application/json'], 'updateCustomer' => ['application/json'], 'updateCustomerCard' => ['application/json'], 'updatePlan' => ['application/json'], 'updatePlatformShop' => ['application/json'], 'updateSubscription' => ['application/json'], 'updateTenantExaminationInfo' => ['application/json'], 'updateTenantExaminationInfoV2' => ['application/json'], 'updateTenantShop' => ['application/json'], 'uploadExaminationFile' => ['multipart/form-data']];

    /**
     * @param int $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(private readonly ClientInterface $client = new Client(), private readonly Configuration $config = new Configuration(), private readonly HeaderSelector $headerSelector = new HeaderSelector(), private int $hostIndex = 0)
    {
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * authorizePayment: 決済 再オーソリ.
     *
     * @param string                                                 $id                              オーダーID（決済情報のID） (required)
     * @param string                                                 $tenantShopId                    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済のオーソリを再度実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardReauthorizingRequest $paymentCardReauthorizingRequest paymentCardReauthorizingRequest (optional)
     * @param string                                                 $contentType                     The value for the Content-Type header. Check self::contentTypes['authorizePayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function authorizePayment(mixed $id, mixed $tenantShopId = null, mixed $paymentCardReauthorizingRequest = null, string $contentType = self::contentTypes['authorizePayment'][0]): mixed
    {
        list($response) = $this->authorizePaymentWithHttpInfo($id, $tenantShopId, $paymentCardReauthorizingRequest, $contentType);

        return $response;
    }

    /**
     * authorizePaymentWithHttpInfo: 決済 再オーソリ.
     *
     * @param string                                                 $id                              オーダーID（決済情報のID） (required)
     * @param string                                                 $tenantShopId                    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済のオーソリを再度実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardReauthorizingRequest $paymentCardReauthorizingRequest (optional)
     * @param string                                                 $contentType                     The value for the Content-Type header. Check self::contentTypes['authorizePayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function authorizePaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentCardReauthorizingRequest = null, string $contentType = self::contentTypes['authorizePayment'][0]): array
    {
        $request = $this->authorizePaymentRequest($id, $tenantShopId, $paymentCardReauthorizingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * authorizePaymentAsync: 決済 再オーソリ.
     *
     * @param string                                                 $id                              オーダーID（決済情報のID） (required)
     * @param string                                                 $tenantShopId                    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済のオーソリを再度実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardReauthorizingRequest $paymentCardReauthorizingRequest (optional)
     * @param string                                                 $contentType                     The value for the Content-Type header. Check self::contentTypes['authorizePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function authorizePaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $paymentCardReauthorizingRequest = null, string $contentType = self::contentTypes['authorizePayment'][0]): PromiseInterface
    {
        return $this->authorizePaymentAsyncWithHttpInfo($id, $tenantShopId, $paymentCardReauthorizingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * authorizePaymentAsyncWithHttpInfo: 決済 再オーソリ.
     *
     * @param string                                                 $id                              オーダーID（決済情報のID） (required)
     * @param string                                                 $tenantShopId                    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済のオーソリを再度実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardReauthorizingRequest $paymentCardReauthorizingRequest (optional)
     * @param string                                                 $contentType                     The value for the Content-Type header. Check self::contentTypes['authorizePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function authorizePaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentCardReauthorizingRequest = null, string $contentType = self::contentTypes['authorizePayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentCardReauthorizingResponse';
        $request = $this->authorizePaymentRequest($id, $tenantShopId, $paymentCardReauthorizingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'authorizePayment'.
     *
     * @param string                                                 $id                              オーダーID（決済情報のID） (required)
     * @param string                                                 $tenantShopId                    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済のオーソリを再度実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardReauthorizingRequest $paymentCardReauthorizingRequest (optional)
     * @param string                                                 $contentType                     The value for the Content-Type header. Check self::contentTypes['authorizePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function authorizePaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $paymentCardReauthorizingRequest = null, string $contentType = self::contentTypes['authorizePayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling authorizePayment');
        }
        $resourcePath = '/v1/payments/{id}/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($paymentCardReauthorizingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentCardReauthorizingRequest));
            } else {
                $httpBody = $paymentCardReauthorizingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * cancelPayment: 決済 キャンセル.
     *
     * @param string                                      $id                   オーダーID（決済情報のID） (required)
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済をキャンセルします。 (optional)
     * @param \OpenAPI\Fincode\Model\CancelPaymentRequest $cancelPaymentRequest cancelPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['cancelPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CancelPayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function cancelPayment(mixed $id, mixed $tenantShopId = null, mixed $cancelPaymentRequest = null, string $contentType = self::contentTypes['cancelPayment'][0]): mixed
    {
        list($response) = $this->cancelPaymentWithHttpInfo($id, $tenantShopId, $cancelPaymentRequest, $contentType);

        return $response;
    }

    /**
     * cancelPaymentWithHttpInfo: 決済 キャンセル.
     *
     * @param string                                      $id                   オーダーID（決済情報のID） (required)
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済をキャンセルします。 (optional)
     * @param \OpenAPI\Fincode\Model\CancelPaymentRequest $cancelPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['cancelPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CancelPayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function cancelPaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $cancelPaymentRequest = null, string $contentType = self::contentTypes['cancelPayment'][0]): array
    {
        $request = $this->cancelPaymentRequest($id, $tenantShopId, $cancelPaymentRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CancelPayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CancelPayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CancelPayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CancelPayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CancelPayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * cancelPaymentAsync: 決済 キャンセル.
     *
     * @param string                                      $id                   オーダーID（決済情報のID） (required)
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済をキャンセルします。 (optional)
     * @param \OpenAPI\Fincode\Model\CancelPaymentRequest $cancelPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['cancelPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function cancelPaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $cancelPaymentRequest = null, string $contentType = self::contentTypes['cancelPayment'][0]): PromiseInterface
    {
        return $this->cancelPaymentAsyncWithHttpInfo($id, $tenantShopId, $cancelPaymentRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * cancelPaymentAsyncWithHttpInfo: 決済 キャンセル.
     *
     * @param string                                      $id                   オーダーID（決済情報のID） (required)
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済をキャンセルします。 (optional)
     * @param \OpenAPI\Fincode\Model\CancelPaymentRequest $cancelPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['cancelPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function cancelPaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $cancelPaymentRequest = null, string $contentType = self::contentTypes['cancelPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CancelPayment200Response';
        $request = $this->cancelPaymentRequest($id, $tenantShopId, $cancelPaymentRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'cancelPayment'.
     *
     * @param string                                      $id                   オーダーID（決済情報のID） (required)
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済をキャンセルします。 (optional)
     * @param \OpenAPI\Fincode\Model\CancelPaymentRequest $cancelPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['cancelPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function cancelPaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $cancelPaymentRequest = null, string $contentType = self::contentTypes['cancelPayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling cancelPayment');
        }
        $resourcePath = '/v1/payments/{id}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($cancelPaymentRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cancelPaymentRequest));
            } else {
                $httpBody = $cancelPaymentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * capturePayment: 決済 売上確定.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の売上確定を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CapturePaymentRequest $capturePaymentRequest capturePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['capturePayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CapturePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function capturePayment(mixed $id, mixed $tenantShopId = null, mixed $capturePaymentRequest = null, string $contentType = self::contentTypes['capturePayment'][0]): mixed
    {
        list($response) = $this->capturePaymentWithHttpInfo($id, $tenantShopId, $capturePaymentRequest, $contentType);

        return $response;
    }

    /**
     * capturePaymentWithHttpInfo: 決済 売上確定.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の売上確定を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CapturePaymentRequest $capturePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['capturePayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CapturePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function capturePaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $capturePaymentRequest = null, string $contentType = self::contentTypes['capturePayment'][0]): array
    {
        $request = $this->capturePaymentRequest($id, $tenantShopId, $capturePaymentRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CapturePayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CapturePayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CapturePayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CapturePayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CapturePayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * capturePaymentAsync: 決済 売上確定.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の売上確定を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CapturePaymentRequest $capturePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['capturePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function capturePaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $capturePaymentRequest = null, string $contentType = self::contentTypes['capturePayment'][0]): PromiseInterface
    {
        return $this->capturePaymentAsyncWithHttpInfo($id, $tenantShopId, $capturePaymentRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * capturePaymentAsyncWithHttpInfo: 決済 売上確定.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の売上確定を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CapturePaymentRequest $capturePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['capturePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function capturePaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $capturePaymentRequest = null, string $contentType = self::contentTypes['capturePayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CapturePayment200Response';
        $request = $this->capturePaymentRequest($id, $tenantShopId, $capturePaymentRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'capturePayment'.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の売上確定を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CapturePaymentRequest $capturePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['capturePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function capturePaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $capturePaymentRequest = null, string $contentType = self::contentTypes['capturePayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling capturePayment');
        }
        $resourcePath = '/v1/payments/{id}/capture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($capturePaymentRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($capturePaymentRequest));
            } else {
                $httpBody = $capturePaymentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * changeAmountOfPayment: 決済 金額変更.
     *
     * @param string                                              $id                           オーダーID（決済情報のID） (required)
     * @param string                                              $tenantShopId                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の利用金額を変更します。 (optional)
     * @param \OpenAPI\Fincode\Model\ChangeAmountOfPaymentRequest $changeAmountOfPaymentRequest changeAmountOfPaymentRequest (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['changeAmountOfPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function changeAmountOfPayment(mixed $id, mixed $tenantShopId = null, mixed $changeAmountOfPaymentRequest = null, string $contentType = self::contentTypes['changeAmountOfPayment'][0]): mixed
    {
        list($response) = $this->changeAmountOfPaymentWithHttpInfo($id, $tenantShopId, $changeAmountOfPaymentRequest, $contentType);

        return $response;
    }

    /**
     * changeAmountOfPaymentWithHttpInfo: 決済 金額変更.
     *
     * @param string                                              $id                           オーダーID（決済情報のID） (required)
     * @param string                                              $tenantShopId                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の利用金額を変更します。 (optional)
     * @param \OpenAPI\Fincode\Model\ChangeAmountOfPaymentRequest $changeAmountOfPaymentRequest (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['changeAmountOfPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function changeAmountOfPaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $changeAmountOfPaymentRequest = null, string $contentType = self::contentTypes['changeAmountOfPayment'][0]): array
    {
        $request = $this->changeAmountOfPaymentRequest($id, $tenantShopId, $changeAmountOfPaymentRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * changeAmountOfPaymentAsync: 決済 金額変更.
     *
     * @param string                                              $id                           オーダーID（決済情報のID） (required)
     * @param string                                              $tenantShopId                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の利用金額を変更します。 (optional)
     * @param \OpenAPI\Fincode\Model\ChangeAmountOfPaymentRequest $changeAmountOfPaymentRequest (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['changeAmountOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function changeAmountOfPaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $changeAmountOfPaymentRequest = null, string $contentType = self::contentTypes['changeAmountOfPayment'][0]): PromiseInterface
    {
        return $this->changeAmountOfPaymentAsyncWithHttpInfo($id, $tenantShopId, $changeAmountOfPaymentRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * changeAmountOfPaymentAsyncWithHttpInfo: 決済 金額変更.
     *
     * @param string                                              $id                           オーダーID（決済情報のID） (required)
     * @param string                                              $tenantShopId                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の利用金額を変更します。 (optional)
     * @param \OpenAPI\Fincode\Model\ChangeAmountOfPaymentRequest $changeAmountOfPaymentRequest (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['changeAmountOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function changeAmountOfPaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $changeAmountOfPaymentRequest = null, string $contentType = self::contentTypes['changeAmountOfPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ChangeAmountOfPayment200Response';
        $request = $this->changeAmountOfPaymentRequest($id, $tenantShopId, $changeAmountOfPaymentRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'changeAmountOfPayment'.
     *
     * @param string                                              $id                           オーダーID（決済情報のID） (required)
     * @param string                                              $tenantShopId                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の利用金額を変更します。 (optional)
     * @param \OpenAPI\Fincode\Model\ChangeAmountOfPaymentRequest $changeAmountOfPaymentRequest (optional)
     * @param string                                              $contentType                  The value for the Content-Type header. Check self::contentTypes['changeAmountOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function changeAmountOfPaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $changeAmountOfPaymentRequest = null, string $contentType = self::contentTypes['changeAmountOfPayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling changeAmountOfPayment');
        }
        $resourcePath = '/v1/payments/{id}/change';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($changeAmountOfPaymentRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeAmountOfPaymentRequest));
            } else {
                $httpBody = $changeAmountOfPaymentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createCardRegistrationSession: カード登録URL 作成.
     *
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上の顧客に対してカードを登録するためのカード登録URLを発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingRequest $cardRegistrationSessionCreatingRequest cardRegistrationSessionCreatingRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['createCardRegistrationSession'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCardRegistrationSession(mixed $tenantShopId = null, mixed $cardRegistrationSessionCreatingRequest = null, string $contentType = self::contentTypes['createCardRegistrationSession'][0]): mixed
    {
        list($response) = $this->createCardRegistrationSessionWithHttpInfo($tenantShopId, $cardRegistrationSessionCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createCardRegistrationSessionWithHttpInfo: カード登録URL 作成.
     *
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上の顧客に対してカードを登録するためのカード登録URLを発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingRequest $cardRegistrationSessionCreatingRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['createCardRegistrationSession'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCardRegistrationSessionWithHttpInfo(mixed $tenantShopId = null, mixed $cardRegistrationSessionCreatingRequest = null, string $contentType = self::contentTypes['createCardRegistrationSession'][0]): array
    {
        $request = $this->createCardRegistrationSessionRequest($tenantShopId, $cardRegistrationSessionCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createCardRegistrationSessionAsync: カード登録URL 作成.
     *
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上の顧客に対してカードを登録するためのカード登録URLを発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingRequest $cardRegistrationSessionCreatingRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['createCardRegistrationSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCardRegistrationSessionAsync(mixed $tenantShopId = null, mixed $cardRegistrationSessionCreatingRequest = null, string $contentType = self::contentTypes['createCardRegistrationSession'][0]): PromiseInterface
    {
        return $this->createCardRegistrationSessionAsyncWithHttpInfo($tenantShopId, $cardRegistrationSessionCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createCardRegistrationSessionAsyncWithHttpInfo: カード登録URL 作成.
     *
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上の顧客に対してカードを登録するためのカード登録URLを発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingRequest $cardRegistrationSessionCreatingRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['createCardRegistrationSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCardRegistrationSessionAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $cardRegistrationSessionCreatingRequest = null, string $contentType = self::contentTypes['createCardRegistrationSession'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CardRegistrationSessionCreatingResponse';
        $request = $this->createCardRegistrationSessionRequest($tenantShopId, $cardRegistrationSessionCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createCardRegistrationSession'.
     *
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップ上の顧客に対してカードを登録するためのカード登録URLを発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\CardRegistrationSessionCreatingRequest $cardRegistrationSessionCreatingRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['createCardRegistrationSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCardRegistrationSessionRequest(mixed $tenantShopId = null, mixed $cardRegistrationSessionCreatingRequest = null, string $contentType = self::contentTypes['createCardRegistrationSession'][0]): Request
    {
        $resourcePath = '/v1/card_sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($cardRegistrationSessionCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cardRegistrationSessionCreatingRequest));
            } else {
                $httpBody = $cardRegistrationSessionCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createCustomer: 顧客 登録.
     *
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに紐づく形で顧客情報を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCreatingRequest $customerCreatingRequest customerCreatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['createCustomer'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomer(mixed $tenantShopId = null, mixed $customerCreatingRequest = null, string $contentType = self::contentTypes['createCustomer'][0]): mixed
    {
        list($response) = $this->createCustomerWithHttpInfo($tenantShopId, $customerCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createCustomerWithHttpInfo: 顧客 登録.
     *
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに紐づく形で顧客情報を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCreatingRequest $customerCreatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['createCustomer'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomerWithHttpInfo(mixed $tenantShopId = null, mixed $customerCreatingRequest = null, string $contentType = self::contentTypes['createCustomer'][0]): array
    {
        $request = $this->createCustomerRequest($tenantShopId, $customerCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createCustomerAsync: 顧客 登録.
     *
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに紐づく形で顧客情報を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCreatingRequest $customerCreatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['createCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerAsync(mixed $tenantShopId = null, mixed $customerCreatingRequest = null, string $contentType = self::contentTypes['createCustomer'][0]): PromiseInterface
    {
        return $this->createCustomerAsyncWithHttpInfo($tenantShopId, $customerCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createCustomerAsyncWithHttpInfo: 顧客 登録.
     *
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに紐づく形で顧客情報を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCreatingRequest $customerCreatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['createCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $customerCreatingRequest = null, string $contentType = self::contentTypes['createCustomer'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCreatingResponse';
        $request = $this->createCustomerRequest($tenantShopId, $customerCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createCustomer'.
     *
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに紐づく形で顧客情報を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCreatingRequest $customerCreatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['createCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerRequest(mixed $tenantShopId = null, mixed $customerCreatingRequest = null, string $contentType = self::contentTypes['createCustomer'][0]): Request
    {
        $resourcePath = '/v1/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($customerCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customerCreatingRequest));
            } else {
                $httpBody = $customerCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createCustomerCard: カード 登録.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対してカードを登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardCreatingRequest $customerCardCreatingRequest customerCardCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createCustomerCard'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCardCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomerCard(mixed $customerId, mixed $tenantShopId = null, mixed $customerCardCreatingRequest = null, string $contentType = self::contentTypes['createCustomerCard'][0]): mixed
    {
        list($response) = $this->createCustomerCardWithHttpInfo($customerId, $tenantShopId, $customerCardCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createCustomerCardWithHttpInfo: カード 登録.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対してカードを登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardCreatingRequest $customerCardCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createCustomerCard'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCardCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomerCardWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, mixed $customerCardCreatingRequest = null, string $contentType = self::contentTypes['createCustomerCard'][0]): array
    {
        $request = $this->createCustomerCardRequest($customerId, $tenantShopId, $customerCardCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCardCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCardCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCardCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCardCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCardCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createCustomerCardAsync: カード 登録.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対してカードを登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardCreatingRequest $customerCardCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerCardAsync(mixed $customerId, mixed $tenantShopId = null, mixed $customerCardCreatingRequest = null, string $contentType = self::contentTypes['createCustomerCard'][0]): PromiseInterface
    {
        return $this->createCustomerCardAsyncWithHttpInfo($customerId, $tenantShopId, $customerCardCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createCustomerCardAsyncWithHttpInfo: カード 登録.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対してカードを登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardCreatingRequest $customerCardCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerCardAsyncWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, mixed $customerCardCreatingRequest = null, string $contentType = self::contentTypes['createCustomerCard'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCardCreatingResponse';
        $request = $this->createCustomerCardRequest($customerId, $tenantShopId, $customerCardCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createCustomerCard'.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対してカードを登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardCreatingRequest $customerCardCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerCardRequest(mixed $customerId, mixed $tenantShopId = null, mixed $customerCardCreatingRequest = null, string $contentType = self::contentTypes['createCustomerCard'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling createCustomerCard');
        }
        $resourcePath = '/v1/customers/{customer_id}/cards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($customerCardCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customerCardCreatingRequest));
            } else {
                $httpBody = $customerCardCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createCustomerPaymentMethod: 決済手段 登録.
     *
     * @param string                                                      $customerId                           顧客ID (required)
     * @param string                                                      $tenantShopId                         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して決済手段を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingRequest $customerPaymentMethodCreatingRequest customerPaymentMethodCreatingRequest (optional)
     * @param string                                                      $contentType                          The value for the Content-Type header. Check self::contentTypes['createCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomerPaymentMethod(mixed $customerId, mixed $tenantShopId = null, mixed $customerPaymentMethodCreatingRequest = null, string $contentType = self::contentTypes['createCustomerPaymentMethod'][0]): mixed
    {
        list($response) = $this->createCustomerPaymentMethodWithHttpInfo($customerId, $tenantShopId, $customerPaymentMethodCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createCustomerPaymentMethodWithHttpInfo: 決済手段 登録.
     *
     * @param string                                                      $customerId                           顧客ID (required)
     * @param string                                                      $tenantShopId                         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して決済手段を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingRequest $customerPaymentMethodCreatingRequest (optional)
     * @param string                                                      $contentType                          The value for the Content-Type header. Check self::contentTypes['createCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createCustomerPaymentMethodWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, mixed $customerPaymentMethodCreatingRequest = null, string $contentType = self::contentTypes['createCustomerPaymentMethod'][0]): array
    {
        $request = $this->createCustomerPaymentMethodRequest($customerId, $tenantShopId, $customerPaymentMethodCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createCustomerPaymentMethodAsync: 決済手段 登録.
     *
     * @param string                                                      $customerId                           顧客ID (required)
     * @param string                                                      $tenantShopId                         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して決済手段を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingRequest $customerPaymentMethodCreatingRequest (optional)
     * @param string                                                      $contentType                          The value for the Content-Type header. Check self::contentTypes['createCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerPaymentMethodAsync(mixed $customerId, mixed $tenantShopId = null, mixed $customerPaymentMethodCreatingRequest = null, string $contentType = self::contentTypes['createCustomerPaymentMethod'][0]): PromiseInterface
    {
        return $this->createCustomerPaymentMethodAsyncWithHttpInfo($customerId, $tenantShopId, $customerPaymentMethodCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createCustomerPaymentMethodAsyncWithHttpInfo: 決済手段 登録.
     *
     * @param string                                                      $customerId                           顧客ID (required)
     * @param string                                                      $tenantShopId                         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して決済手段を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingRequest $customerPaymentMethodCreatingRequest (optional)
     * @param string                                                      $contentType                          The value for the Content-Type header. Check self::contentTypes['createCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerPaymentMethodAsyncWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, mixed $customerPaymentMethodCreatingRequest = null, string $contentType = self::contentTypes['createCustomerPaymentMethod'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingResponse';
        $request = $this->createCustomerPaymentMethodRequest($customerId, $tenantShopId, $customerPaymentMethodCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createCustomerPaymentMethod'.
     *
     * @param string                                                      $customerId                           顧客ID (required)
     * @param string                                                      $tenantShopId                         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して決済手段を登録します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodCreatingRequest $customerPaymentMethodCreatingRequest (optional)
     * @param string                                                      $contentType                          The value for the Content-Type header. Check self::contentTypes['createCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createCustomerPaymentMethodRequest(mixed $customerId, mixed $tenantShopId = null, mixed $customerPaymentMethodCreatingRequest = null, string $contentType = self::contentTypes['createCustomerPaymentMethod'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling createCustomerPaymentMethod');
        }
        $resourcePath = '/v1/customers/{customer_id}/payment_methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($customerPaymentMethodCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customerPaymentMethodCreatingRequest));
            } else {
                $httpBody = $customerPaymentMethodCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createPayment: 決済 登録.
     *
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主として決済を登録します。テナントが&#x60;pay_type&#x60;で指定する決済手段契約の審査を完了させている必要があります。 (optional)
     * @param \OpenAPI\Fincode\Model\CreatePaymentRequest $createPaymentRequest createPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['createPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CreatePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPayment(mixed $tenantShopId = null, mixed $createPaymentRequest = null, string $contentType = self::contentTypes['createPayment'][0]): mixed
    {
        list($response) = $this->createPaymentWithHttpInfo($tenantShopId, $createPaymentRequest, $contentType);

        return $response;
    }

    /**
     * createPaymentWithHttpInfo: 決済 登録.
     *
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主として決済を登録します。テナントが&#x60;pay_type&#x60;で指定する決済手段契約の審査を完了させている必要があります。 (optional)
     * @param \OpenAPI\Fincode\Model\CreatePaymentRequest $createPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['createPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CreatePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPaymentWithHttpInfo(mixed $tenantShopId = null, mixed $createPaymentRequest = null, string $contentType = self::contentTypes['createPayment'][0]): array
    {
        $request = $this->createPaymentRequest($tenantShopId, $createPaymentRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CreatePayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CreatePayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CreatePayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CreatePayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CreatePayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createPaymentAsync: 決済 登録.
     *
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主として決済を登録します。テナントが&#x60;pay_type&#x60;で指定する決済手段契約の審査を完了させている必要があります。 (optional)
     * @param \OpenAPI\Fincode\Model\CreatePaymentRequest $createPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['createPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentAsync(mixed $tenantShopId = null, mixed $createPaymentRequest = null, string $contentType = self::contentTypes['createPayment'][0]): PromiseInterface
    {
        return $this->createPaymentAsyncWithHttpInfo($tenantShopId, $createPaymentRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createPaymentAsyncWithHttpInfo: 決済 登録.
     *
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主として決済を登録します。テナントが&#x60;pay_type&#x60;で指定する決済手段契約の審査を完了させている必要があります。 (optional)
     * @param \OpenAPI\Fincode\Model\CreatePaymentRequest $createPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['createPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $createPaymentRequest = null, string $contentType = self::contentTypes['createPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CreatePayment200Response';
        $request = $this->createPaymentRequest($tenantShopId, $createPaymentRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createPayment'.
     *
     * @param string                                      $tenantShopId         &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主として決済を登録します。テナントが&#x60;pay_type&#x60;で指定する決済手段契約の審査を完了させている必要があります。 (optional)
     * @param \OpenAPI\Fincode\Model\CreatePaymentRequest $createPaymentRequest (optional)
     * @param string                                      $contentType          The value for the Content-Type header. Check self::contentTypes['createPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentRequest(mixed $tenantShopId = null, mixed $createPaymentRequest = null, string $contentType = self::contentTypes['createPayment'][0]): Request
    {
        $resourcePath = '/v1/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($createPaymentRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createPaymentRequest));
            } else {
                $httpBody = $createPaymentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createPaymentBulk: 一括決済 登録.
     *
     * @param \OpenAPI\Fincode\Model\PaymentBulkPayType $payType         payType (required)
     * @param string                                    $processPlanDate processPlanDate (required)
     * @param string                                    $tenantShopId    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済情報を一括登録します。 (optional)
     * @param string                                    $file            一括決済情報を記載したJSONファイル。\\\\ \\\\ 以下のようなファイルをアップロードします。 &#x60;&#x60;&#x60;json {     \\\&quot;data\\\&quot;: [         {             \\\&quot;id\\\&quot;: \\\&quot;order_001\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;tax\\\&quot;: \\\&quot;100\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;,             \\\&quot;client_field_1\\\&quot;: \\\&quot;自由項目1\\\&quot;,             \\\&quot;client_field_2\\\&quot;: \\\&quot;自由項目2\\\&quot;,             \\\&quot;client_field_3\\\&quot;: \\\&quot;自由項目3\\\&quot;         },         {             \\\&quot;id\\\&quot;: \\\&quot;order_002\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;         },         ...     ] } &#x60;&#x60;&#x60; パラメータ仕様は以下の通りで、各パラメータの形式は決済登録・決済実行APIに準拠します。（*は必須項目）  - &#x60;data&#x60;: 決済情報のリストを格納する配列 - &#x60;data[].id&#x60;: オーダーID* - &#x60;data[].amount&#x60;: 利用金額* - &#x60;data[].tax&#x60;: 税送料 - &#x60;data[].customer_id&#x60;: 顧客ID* - &#x60;data[].card_id&#x60;: カードID - &#x60;data[].client_field_1&#x60;: 自由項目1 - &#x60;data[].client_field_2&#x60;: 自由項目2 - &#x60;data[].client_field_3&#x60;: 自由項目3 (optional)
     * @param string                                    $contentType     The value for the Content-Type header. Check self::contentTypes['createPaymentBulk'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentBulkCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPaymentBulk(mixed $payType, mixed $processPlanDate, mixed $tenantShopId = null, mixed $file = null, string $contentType = self::contentTypes['createPaymentBulk'][0]): mixed
    {
        list($response) = $this->createPaymentBulkWithHttpInfo($payType, $processPlanDate, $tenantShopId, $file, $contentType);

        return $response;
    }

    /**
     * createPaymentBulkWithHttpInfo: 一括決済 登録.
     *
     * @param \OpenAPI\Fincode\Model\PaymentBulkPayType $payType         (required)
     * @param string                                    $processPlanDate (required)
     * @param string                                    $tenantShopId    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済情報を一括登録します。 (optional)
     * @param string                                    $file            一括決済情報を記載したJSONファイル。\\\\ \\\\ 以下のようなファイルをアップロードします。 &#x60;&#x60;&#x60;json {     \\\&quot;data\\\&quot;: [         {             \\\&quot;id\\\&quot;: \\\&quot;order_001\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;tax\\\&quot;: \\\&quot;100\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;,             \\\&quot;client_field_1\\\&quot;: \\\&quot;自由項目1\\\&quot;,             \\\&quot;client_field_2\\\&quot;: \\\&quot;自由項目2\\\&quot;,             \\\&quot;client_field_3\\\&quot;: \\\&quot;自由項目3\\\&quot;         },         {             \\\&quot;id\\\&quot;: \\\&quot;order_002\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;         },         ...     ] } &#x60;&#x60;&#x60; パラメータ仕様は以下の通りで、各パラメータの形式は決済登録・決済実行APIに準拠します。（*は必須項目）  - &#x60;data&#x60;: 決済情報のリストを格納する配列 - &#x60;data[].id&#x60;: オーダーID* - &#x60;data[].amount&#x60;: 利用金額* - &#x60;data[].tax&#x60;: 税送料 - &#x60;data[].customer_id&#x60;: 顧客ID* - &#x60;data[].card_id&#x60;: カードID - &#x60;data[].client_field_1&#x60;: 自由項目1 - &#x60;data[].client_field_2&#x60;: 自由項目2 - &#x60;data[].client_field_3&#x60;: 自由項目3 (optional)
     * @param string                                    $contentType     The value for the Content-Type header. Check self::contentTypes['createPaymentBulk'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentBulkCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPaymentBulkWithHttpInfo(mixed $payType, mixed $processPlanDate, mixed $tenantShopId = null, mixed $file = null, string $contentType = self::contentTypes['createPaymentBulk'][0]): array
    {
        $request = $this->createPaymentBulkRequest($payType, $processPlanDate, $tenantShopId, $file, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createPaymentBulkAsync: 一括決済 登録.
     *
     * @param \OpenAPI\Fincode\Model\PaymentBulkPayType $payType         (required)
     * @param string                                    $processPlanDate (required)
     * @param string                                    $tenantShopId    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済情報を一括登録します。 (optional)
     * @param string                                    $file            一括決済情報を記載したJSONファイル。\\\\ \\\\ 以下のようなファイルをアップロードします。 &#x60;&#x60;&#x60;json {     \\\&quot;data\\\&quot;: [         {             \\\&quot;id\\\&quot;: \\\&quot;order_001\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;tax\\\&quot;: \\\&quot;100\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;,             \\\&quot;client_field_1\\\&quot;: \\\&quot;自由項目1\\\&quot;,             \\\&quot;client_field_2\\\&quot;: \\\&quot;自由項目2\\\&quot;,             \\\&quot;client_field_3\\\&quot;: \\\&quot;自由項目3\\\&quot;         },         {             \\\&quot;id\\\&quot;: \\\&quot;order_002\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;         },         ...     ] } &#x60;&#x60;&#x60; パラメータ仕様は以下の通りで、各パラメータの形式は決済登録・決済実行APIに準拠します。（*は必須項目）  - &#x60;data&#x60;: 決済情報のリストを格納する配列 - &#x60;data[].id&#x60;: オーダーID* - &#x60;data[].amount&#x60;: 利用金額* - &#x60;data[].tax&#x60;: 税送料 - &#x60;data[].customer_id&#x60;: 顧客ID* - &#x60;data[].card_id&#x60;: カードID - &#x60;data[].client_field_1&#x60;: 自由項目1 - &#x60;data[].client_field_2&#x60;: 自由項目2 - &#x60;data[].client_field_3&#x60;: 自由項目3 (optional)
     * @param string                                    $contentType     The value for the Content-Type header. Check self::contentTypes['createPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentBulkAsync(mixed $payType, mixed $processPlanDate, mixed $tenantShopId = null, mixed $file = null, string $contentType = self::contentTypes['createPaymentBulk'][0]): PromiseInterface
    {
        return $this->createPaymentBulkAsyncWithHttpInfo($payType, $processPlanDate, $tenantShopId, $file, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createPaymentBulkAsyncWithHttpInfo: 一括決済 登録.
     *
     * @param \OpenAPI\Fincode\Model\PaymentBulkPayType $payType         (required)
     * @param string                                    $processPlanDate (required)
     * @param string                                    $tenantShopId    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済情報を一括登録します。 (optional)
     * @param string                                    $file            一括決済情報を記載したJSONファイル。\\\\ \\\\ 以下のようなファイルをアップロードします。 &#x60;&#x60;&#x60;json {     \\\&quot;data\\\&quot;: [         {             \\\&quot;id\\\&quot;: \\\&quot;order_001\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;tax\\\&quot;: \\\&quot;100\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;,             \\\&quot;client_field_1\\\&quot;: \\\&quot;自由項目1\\\&quot;,             \\\&quot;client_field_2\\\&quot;: \\\&quot;自由項目2\\\&quot;,             \\\&quot;client_field_3\\\&quot;: \\\&quot;自由項目3\\\&quot;         },         {             \\\&quot;id\\\&quot;: \\\&quot;order_002\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;         },         ...     ] } &#x60;&#x60;&#x60; パラメータ仕様は以下の通りで、各パラメータの形式は決済登録・決済実行APIに準拠します。（*は必須項目）  - &#x60;data&#x60;: 決済情報のリストを格納する配列 - &#x60;data[].id&#x60;: オーダーID* - &#x60;data[].amount&#x60;: 利用金額* - &#x60;data[].tax&#x60;: 税送料 - &#x60;data[].customer_id&#x60;: 顧客ID* - &#x60;data[].card_id&#x60;: カードID - &#x60;data[].client_field_1&#x60;: 自由項目1 - &#x60;data[].client_field_2&#x60;: 自由項目2 - &#x60;data[].client_field_3&#x60;: 自由項目3 (optional)
     * @param string                                    $contentType     The value for the Content-Type header. Check self::contentTypes['createPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentBulkAsyncWithHttpInfo(mixed $payType, mixed $processPlanDate, mixed $tenantShopId = null, mixed $file = null, string $contentType = self::contentTypes['createPaymentBulk'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentBulkCreatingResponse';
        $request = $this->createPaymentBulkRequest($payType, $processPlanDate, $tenantShopId, $file, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createPaymentBulk'.
     *
     * @param \OpenAPI\Fincode\Model\PaymentBulkPayType $payType         (required)
     * @param string                                    $processPlanDate (required)
     * @param string                                    $tenantShopId    &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済情報を一括登録します。 (optional)
     * @param string                                    $file            一括決済情報を記載したJSONファイル。\\\\ \\\\ 以下のようなファイルをアップロードします。 &#x60;&#x60;&#x60;json {     \\\&quot;data\\\&quot;: [         {             \\\&quot;id\\\&quot;: \\\&quot;order_001\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;tax\\\&quot;: \\\&quot;100\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;,             \\\&quot;client_field_1\\\&quot;: \\\&quot;自由項目1\\\&quot;,             \\\&quot;client_field_2\\\&quot;: \\\&quot;自由項目2\\\&quot;,             \\\&quot;client_field_3\\\&quot;: \\\&quot;自由項目3\\\&quot;         },         {             \\\&quot;id\\\&quot;: \\\&quot;order_002\\\&quot;,             \\\&quot;amount\\\&quot;: \\\&quot;1000\\\&quot;,             \\\&quot;customer_id\\\&quot;: \\\&quot;c_**********************\\\&quot;,             \\\&quot;card_id\\\&quot;: \\\&quot;cs_**********************\\\&quot;         },         ...     ] } &#x60;&#x60;&#x60; パラメータ仕様は以下の通りで、各パラメータの形式は決済登録・決済実行APIに準拠します。（*は必須項目）  - &#x60;data&#x60;: 決済情報のリストを格納する配列 - &#x60;data[].id&#x60;: オーダーID* - &#x60;data[].amount&#x60;: 利用金額* - &#x60;data[].tax&#x60;: 税送料 - &#x60;data[].customer_id&#x60;: 顧客ID* - &#x60;data[].card_id&#x60;: カードID - &#x60;data[].client_field_1&#x60;: 自由項目1 - &#x60;data[].client_field_2&#x60;: 自由項目2 - &#x60;data[].client_field_3&#x60;: 自由項目3 (optional)
     * @param string                                    $contentType     The value for the Content-Type header. Check self::contentTypes['createPaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentBulkRequest(mixed $payType, mixed $processPlanDate, mixed $tenantShopId = null, mixed $file = null, string $contentType = self::contentTypes['createPaymentBulk'][0]): Request
    {
        // verify the required parameter 'payType' is set
        if (null === $payType || is_array($payType) && 0 === count($payType)) {
            throw new \InvalidArgumentException('Missing the required parameter $payType when calling createPaymentBulk');
        }
        // verify the required parameter 'processPlanDate' is set
        if (null === $processPlanDate || is_array($processPlanDate) && 0 === count($processPlanDate)) {
            throw new \InvalidArgumentException('Missing the required parameter $processPlanDate when calling createPaymentBulk');
        }
        $resourcePath = '/v1/payments/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payType,
            'pay_type',
            // param base name
            'PaymentBulkPayType',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $processPlanDate,
            'process_plan_date',
            // param base name
            'string',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // form params
        if (null !== $file) {
            $formParams['file'] = ObjectSerializer::toFormValue($file);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createPaymentSession: 決済URL 作成.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップで決済を行います。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentSessionCreatingRequest $paymentSessionCreatingRequest paymentSessionCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentSessionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPaymentSession(mixed $tenantShopId = null, mixed $paymentSessionCreatingRequest = null, string $contentType = self::contentTypes['createPaymentSession'][0]): mixed
    {
        list($response) = $this->createPaymentSessionWithHttpInfo($tenantShopId, $paymentSessionCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createPaymentSessionWithHttpInfo: 決済URL 作成.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップで決済を行います。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentSessionCreatingRequest $paymentSessionCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentSessionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPaymentSessionWithHttpInfo(mixed $tenantShopId = null, mixed $paymentSessionCreatingRequest = null, string $contentType = self::contentTypes['createPaymentSession'][0]): array
    {
        $request = $this->createPaymentSessionRequest($tenantShopId, $paymentSessionCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createPaymentSessionAsync: 決済URL 作成.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップで決済を行います。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentSessionCreatingRequest $paymentSessionCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentSessionAsync(mixed $tenantShopId = null, mixed $paymentSessionCreatingRequest = null, string $contentType = self::contentTypes['createPaymentSession'][0]): PromiseInterface
    {
        return $this->createPaymentSessionAsyncWithHttpInfo($tenantShopId, $paymentSessionCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createPaymentSessionAsyncWithHttpInfo: 決済URL 作成.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップで決済を行います。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentSessionCreatingRequest $paymentSessionCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentSessionAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $paymentSessionCreatingRequest = null, string $contentType = self::contentTypes['createPaymentSession'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentSessionCreatingResponse';
        $request = $this->createPaymentSessionRequest($tenantShopId, $paymentSessionCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createPaymentSession'.
     *
     * @param string                                               $tenantShopId                  &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップで決済を行います。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentSessionCreatingRequest $paymentSessionCreatingRequest (optional)
     * @param string                                               $contentType                   The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPaymentSessionRequest(mixed $tenantShopId = null, mixed $paymentSessionCreatingRequest = null, string $contentType = self::contentTypes['createPaymentSession'][0]): Request
    {
        $resourcePath = '/v1/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($paymentSessionCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentSessionCreatingRequest));
            } else {
                $httpBody = $paymentSessionCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createPlan: プラン 登録.
     *
     * @param \OpenAPI\Fincode\Model\PlanCreatingRequest $planCreatingRequest planCreatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['createPlan'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlanCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPlan(mixed $planCreatingRequest = null, string $contentType = self::contentTypes['createPlan'][0]): mixed
    {
        list($response) = $this->createPlanWithHttpInfo($planCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createPlanWithHttpInfo: プラン 登録.
     *
     * @param \OpenAPI\Fincode\Model\PlanCreatingRequest $planCreatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['createPlan'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlanCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createPlanWithHttpInfo(mixed $planCreatingRequest = null, string $contentType = self::contentTypes['createPlan'][0]): array
    {
        $request = $this->createPlanRequest($planCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlanCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlanCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlanCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlanCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlanCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createPlanAsync: プラン 登録.
     *
     * @param \OpenAPI\Fincode\Model\PlanCreatingRequest $planCreatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['createPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPlanAsync(mixed $planCreatingRequest = null, string $contentType = self::contentTypes['createPlan'][0]): PromiseInterface
    {
        return $this->createPlanAsyncWithHttpInfo($planCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createPlanAsyncWithHttpInfo: プラン 登録.
     *
     * @param \OpenAPI\Fincode\Model\PlanCreatingRequest $planCreatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['createPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPlanAsyncWithHttpInfo(mixed $planCreatingRequest = null, string $contentType = self::contentTypes['createPlan'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlanCreatingResponse';
        $request = $this->createPlanRequest($planCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createPlan'.
     *
     * @param \OpenAPI\Fincode\Model\PlanCreatingRequest $planCreatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['createPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createPlanRequest(mixed $planCreatingRequest = null, string $contentType = self::contentTypes['createPlan'][0]): Request
    {
        $resourcePath = '/v1/plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($planCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($planCreatingRequest));
            } else {
                $httpBody = $planCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createSubscription: サブスクリプション 登録.
     *
     * @param \OpenAPI\Fincode\Model\SubscriptionCreatingRequest $subscriptionCreatingRequest subscriptionCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createSubscription(mixed $subscriptionCreatingRequest = null, string $contentType = self::contentTypes['createSubscription'][0]): mixed
    {
        list($response) = $this->createSubscriptionWithHttpInfo($subscriptionCreatingRequest, $contentType);

        return $response;
    }

    /**
     * createSubscriptionWithHttpInfo: サブスクリプション 登録.
     *
     * @param \OpenAPI\Fincode\Model\SubscriptionCreatingRequest $subscriptionCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionCreatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createSubscriptionWithHttpInfo(mixed $subscriptionCreatingRequest = null, string $contentType = self::contentTypes['createSubscription'][0]): array
    {
        $request = $this->createSubscriptionRequest($subscriptionCreatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionCreatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionCreatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionCreatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionCreatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionCreatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createSubscriptionAsync: サブスクリプション 登録.
     *
     * @param \OpenAPI\Fincode\Model\SubscriptionCreatingRequest $subscriptionCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createSubscriptionAsync(mixed $subscriptionCreatingRequest = null, string $contentType = self::contentTypes['createSubscription'][0]): PromiseInterface
    {
        return $this->createSubscriptionAsyncWithHttpInfo($subscriptionCreatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createSubscriptionAsyncWithHttpInfo: サブスクリプション 登録.
     *
     * @param \OpenAPI\Fincode\Model\SubscriptionCreatingRequest $subscriptionCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createSubscriptionAsyncWithHttpInfo(mixed $subscriptionCreatingRequest = null, string $contentType = self::contentTypes['createSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionCreatingResponse';
        $request = $this->createSubscriptionRequest($subscriptionCreatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createSubscription'.
     *
     * @param \OpenAPI\Fincode\Model\SubscriptionCreatingRequest $subscriptionCreatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['createSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createSubscriptionRequest(mixed $subscriptionCreatingRequest = null, string $contentType = self::contentTypes['createSubscription'][0]): Request
    {
        $resourcePath = '/v1/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($subscriptionCreatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscriptionCreatingRequest));
            } else {
                $httpBody = $subscriptionCreatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createTenantWithExistingUser: テナントショップ 作成（既存ユーザー参加）.
     *
     * @param \OpenAPI\Fincode\Model\POSTJoinTenantsRequest $pOSTJoinTenantsRequest pOSTJoinTenantsRequest (optional)
     * @param string                                        $contentType            The value for the Content-Type header. Check self::contentTypes['createTenantWithExistingUser'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\POSTJoinTenantsResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createTenantWithExistingUser(mixed $pOSTJoinTenantsRequest = null, string $contentType = self::contentTypes['createTenantWithExistingUser'][0]): mixed
    {
        list($response) = $this->createTenantWithExistingUserWithHttpInfo($pOSTJoinTenantsRequest, $contentType);

        return $response;
    }

    /**
     * createTenantWithExistingUserWithHttpInfo: テナントショップ 作成（既存ユーザー参加）.
     *
     * @param \OpenAPI\Fincode\Model\POSTJoinTenantsRequest $pOSTJoinTenantsRequest (optional)
     * @param string                                        $contentType            The value for the Content-Type header. Check self::contentTypes['createTenantWithExistingUser'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\POSTJoinTenantsResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createTenantWithExistingUserWithHttpInfo(mixed $pOSTJoinTenantsRequest = null, string $contentType = self::contentTypes['createTenantWithExistingUser'][0]): array
    {
        $request = $this->createTenantWithExistingUserRequest($pOSTJoinTenantsRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\POSTJoinTenantsResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\POSTJoinTenantsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\POSTJoinTenantsResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\POSTJoinTenantsResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\POSTJoinTenantsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createTenantWithExistingUserAsync: テナントショップ 作成（既存ユーザー参加）.
     *
     * @param \OpenAPI\Fincode\Model\POSTJoinTenantsRequest $pOSTJoinTenantsRequest (optional)
     * @param string                                        $contentType            The value for the Content-Type header. Check self::contentTypes['createTenantWithExistingUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithExistingUserAsync(mixed $pOSTJoinTenantsRequest = null, string $contentType = self::contentTypes['createTenantWithExistingUser'][0]): PromiseInterface
    {
        return $this->createTenantWithExistingUserAsyncWithHttpInfo($pOSTJoinTenantsRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createTenantWithExistingUserAsyncWithHttpInfo: テナントショップ 作成（既存ユーザー参加）.
     *
     * @param \OpenAPI\Fincode\Model\POSTJoinTenantsRequest $pOSTJoinTenantsRequest (optional)
     * @param string                                        $contentType            The value for the Content-Type header. Check self::contentTypes['createTenantWithExistingUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithExistingUserAsyncWithHttpInfo(mixed $pOSTJoinTenantsRequest = null, string $contentType = self::contentTypes['createTenantWithExistingUser'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\POSTJoinTenantsResponse';
        $request = $this->createTenantWithExistingUserRequest($pOSTJoinTenantsRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createTenantWithExistingUser'.
     *
     * @param \OpenAPI\Fincode\Model\POSTJoinTenantsRequest $pOSTJoinTenantsRequest (optional)
     * @param string                                        $contentType            The value for the Content-Type header. Check self::contentTypes['createTenantWithExistingUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithExistingUserRequest(mixed $pOSTJoinTenantsRequest = null, string $contentType = self::contentTypes['createTenantWithExistingUser'][0]): Request
    {
        $resourcePath = '/v1/join_tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($pOSTJoinTenantsRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pOSTJoinTenantsRequest));
            } else {
                $httpBody = $pOSTJoinTenantsRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * createTenantWithNewUser: テナントショップ 作成（新規ユーザー登録）.
     *
     * @param \OpenAPI\Fincode\Model\POSTTenantEntriesRequest $pOSTTenantEntriesRequest pOSTTenantEntriesRequest (optional)
     * @param string                                          $contentType              The value for the Content-Type header. Check self::contentTypes['createTenantWithNewUser'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\POSTTenantEntriesResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createTenantWithNewUser(mixed $pOSTTenantEntriesRequest = null, string $contentType = self::contentTypes['createTenantWithNewUser'][0]): mixed
    {
        list($response) = $this->createTenantWithNewUserWithHttpInfo($pOSTTenantEntriesRequest, $contentType);

        return $response;
    }

    /**
     * createTenantWithNewUserWithHttpInfo: テナントショップ 作成（新規ユーザー登録）.
     *
     * @param \OpenAPI\Fincode\Model\POSTTenantEntriesRequest $pOSTTenantEntriesRequest (optional)
     * @param string                                          $contentType              The value for the Content-Type header. Check self::contentTypes['createTenantWithNewUser'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\POSTTenantEntriesResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function createTenantWithNewUserWithHttpInfo(mixed $pOSTTenantEntriesRequest = null, string $contentType = self::contentTypes['createTenantWithNewUser'][0]): array
    {
        $request = $this->createTenantWithNewUserRequest($pOSTTenantEntriesRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\POSTTenantEntriesResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\POSTTenantEntriesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\POSTTenantEntriesResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\POSTTenantEntriesResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\POSTTenantEntriesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * createTenantWithNewUserAsync: テナントショップ 作成（新規ユーザー登録）.
     *
     * @param \OpenAPI\Fincode\Model\POSTTenantEntriesRequest $pOSTTenantEntriesRequest (optional)
     * @param string                                          $contentType              The value for the Content-Type header. Check self::contentTypes['createTenantWithNewUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithNewUserAsync(mixed $pOSTTenantEntriesRequest = null, string $contentType = self::contentTypes['createTenantWithNewUser'][0]): PromiseInterface
    {
        return $this->createTenantWithNewUserAsyncWithHttpInfo($pOSTTenantEntriesRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * createTenantWithNewUserAsyncWithHttpInfo: テナントショップ 作成（新規ユーザー登録）.
     *
     * @param \OpenAPI\Fincode\Model\POSTTenantEntriesRequest $pOSTTenantEntriesRequest (optional)
     * @param string                                          $contentType              The value for the Content-Type header. Check self::contentTypes['createTenantWithNewUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithNewUserAsyncWithHttpInfo(mixed $pOSTTenantEntriesRequest = null, string $contentType = self::contentTypes['createTenantWithNewUser'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\POSTTenantEntriesResponse';
        $request = $this->createTenantWithNewUserRequest($pOSTTenantEntriesRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'createTenantWithNewUser'.
     *
     * @param \OpenAPI\Fincode\Model\POSTTenantEntriesRequest $pOSTTenantEntriesRequest (optional)
     * @param string                                          $contentType              The value for the Content-Type header. Check self::contentTypes['createTenantWithNewUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function createTenantWithNewUserRequest(mixed $pOSTTenantEntriesRequest = null, string $contentType = self::contentTypes['createTenantWithNewUser'][0]): Request
    {
        $resourcePath = '/v1/tenant_entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($pOSTTenantEntriesRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pOSTTenantEntriesRequest));
            } else {
                $httpBody = $pOSTTenantEntriesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deleteCustomer: 顧客 削除.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomer'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomer(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomer'][0]): mixed
    {
        list($response) = $this->deleteCustomerWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * deleteCustomerWithHttpInfo: 顧客 削除.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomer'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomer'][0]): array
    {
        $request = $this->deleteCustomerRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deleteCustomerAsync: 顧客 削除.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomer'][0]): PromiseInterface
    {
        return $this->deleteCustomerAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deleteCustomerAsyncWithHttpInfo: 顧客 削除.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomer'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerDeletingResponse';
        $request = $this->deleteCustomerRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deleteCustomer'.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomer'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deleteCustomer');
        }
        $resourcePath = '/v1/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deleteCustomerCard: カード 削除.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           削除するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードを削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerCard'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCardDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerCard(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerCard'][0]): mixed
    {
        list($response) = $this->deleteCustomerCardWithHttpInfo($customerId, $id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * deleteCustomerCardWithHttpInfo: カード 削除.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           削除するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードを削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerCard'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCardDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerCardWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerCard'][0]): array
    {
        $request = $this->deleteCustomerCardRequest($customerId, $id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCardDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCardDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCardDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCardDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCardDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deleteCustomerCardAsync: カード 削除.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           削除するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードを削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerCardAsync(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerCard'][0]): PromiseInterface
    {
        return $this->deleteCustomerCardAsyncWithHttpInfo($customerId, $id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deleteCustomerCardAsyncWithHttpInfo: カード 削除.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           削除するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードを削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerCardAsyncWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerCard'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCardDeletingResponse';
        $request = $this->deleteCustomerCardRequest($customerId, $id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deleteCustomerCard'.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           削除するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードを削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerCardRequest(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerCard'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling deleteCustomerCard');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deleteCustomerCard');
        }
        $resourcePath = '/v1/customers/{customer_id}/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deleteCustomerPaymentMethod: 決済手段 削除.
     *
     * @param string $customerId   顧客ID (required)
     * @param string $id           決済手段ID (required)
     * @param string $payType      payType (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerPaymentMethod(mixed $customerId, mixed $id, mixed $payType, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerPaymentMethod'][0]): mixed
    {
        list($response) = $this->deleteCustomerPaymentMethodWithHttpInfo($customerId, $id, $payType, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * deleteCustomerPaymentMethodWithHttpInfo: 決済手段 削除.
     *
     * @param string $customerId   顧客ID (required)
     * @param string $id           決済手段ID (required)
     * @param string $payType      (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerPaymentMethodWithHttpInfo(mixed $customerId, mixed $id, mixed $payType, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerPaymentMethod'][0]): array
    {
        $request = $this->deleteCustomerPaymentMethodRequest($customerId, $id, $payType, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deleteCustomerPaymentMethodAsync: 決済手段 削除.
     *
     * @param string $customerId   顧客ID (required)
     * @param string $id           決済手段ID (required)
     * @param string $payType      (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerPaymentMethodAsync(mixed $customerId, mixed $id, mixed $payType, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerPaymentMethod'][0]): PromiseInterface
    {
        return $this->deleteCustomerPaymentMethodAsyncWithHttpInfo($customerId, $id, $payType, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deleteCustomerPaymentMethodAsyncWithHttpInfo: 決済手段 削除.
     *
     * @param string $customerId   顧客ID (required)
     * @param string $id           決済手段ID (required)
     * @param string $payType      (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerPaymentMethodAsyncWithHttpInfo(mixed $customerId, mixed $id, mixed $payType, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerPaymentMethod'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodDeletingResponse';
        $request = $this->deleteCustomerPaymentMethodRequest($customerId, $id, $payType, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deleteCustomerPaymentMethod'.
     *
     * @param string $customerId   顧客ID (required)
     * @param string $id           決済手段ID (required)
     * @param string $payType      (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deleteCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deleteCustomerPaymentMethodRequest(mixed $customerId, mixed $id, mixed $payType, mixed $tenantShopId = null, string $contentType = self::contentTypes['deleteCustomerPaymentMethod'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling deleteCustomerPaymentMethod');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deleteCustomerPaymentMethod');
        }
        // verify the required parameter 'payType' is set
        if (null === $payType || is_array($payType) && 0 === count($payType)) {
            throw new \InvalidArgumentException('Missing the required parameter $payType when calling deleteCustomerPaymentMethod');
        }
        $resourcePath = '/v1/customers/{customer_id}/payment_methods/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payType,
            'pay_type',
            // param base name
            'string',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deletePaymentBulk: 一括決済 削除.
     *
     * @param string $id           一括決済ID。\\ 削除対象の一括決済情報のIDを指定します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deletePaymentBulk'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentBulkDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deletePaymentBulk(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deletePaymentBulk'][0]): mixed
    {
        list($response) = $this->deletePaymentBulkWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * deletePaymentBulkWithHttpInfo: 一括決済 削除.
     *
     * @param string $id           一括決済ID。\\ 削除対象の一括決済情報のIDを指定します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deletePaymentBulk'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentBulkDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deletePaymentBulkWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deletePaymentBulk'][0]): array
    {
        $request = $this->deletePaymentBulkRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deletePaymentBulkAsync: 一括決済 削除.
     *
     * @param string $id           一括決済ID。\\ 削除対象の一括決済情報のIDを指定します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deletePaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePaymentBulkAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deletePaymentBulk'][0]): PromiseInterface
    {
        return $this->deletePaymentBulkAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deletePaymentBulkAsyncWithHttpInfo: 一括決済 削除.
     *
     * @param string $id           一括決済ID。\\ 削除対象の一括決済情報のIDを指定します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deletePaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePaymentBulkAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deletePaymentBulk'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentBulkDeletingResponse';
        $request = $this->deletePaymentBulkRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deletePaymentBulk'.
     *
     * @param string $id           一括決済ID。\\ 削除対象の一括決済情報のIDを指定します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を削除します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['deletePaymentBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePaymentBulkRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['deletePaymentBulk'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deletePaymentBulk');
        }
        $resourcePath = '/v1/payments/bulk/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * deletePlan: プラン 削除.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlan'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlanDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deletePlan(mixed $id, string $contentType = self::contentTypes['deletePlan'][0]): mixed
    {
        list($response) = $this->deletePlanWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * deletePlanWithHttpInfo: プラン 削除.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlan'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlanDeletingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function deletePlanWithHttpInfo(mixed $id, string $contentType = self::contentTypes['deletePlan'][0]): array
    {
        $request = $this->deletePlanRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlanDeletingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlanDeletingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlanDeletingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlanDeletingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlanDeletingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * deletePlanAsync: プラン 削除.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePlanAsync(mixed $id, string $contentType = self::contentTypes['deletePlan'][0]): PromiseInterface
    {
        return $this->deletePlanAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * deletePlanAsyncWithHttpInfo: プラン 削除.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePlanAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['deletePlan'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlanDeletingResponse';
        $request = $this->deletePlanRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'deletePlan'.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function deletePlanRequest(mixed $id, string $contentType = self::contentTypes['deletePlan'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deletePlan');
        }
        $resourcePath = '/v1/plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * executePayment: 決済 実行.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済処理を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\ExecutePaymentRequest $executePaymentRequest executePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['executePayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExecutePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function executePayment(mixed $id, mixed $tenantShopId = null, mixed $executePaymentRequest = null, string $contentType = self::contentTypes['executePayment'][0]): mixed
    {
        list($response) = $this->executePaymentWithHttpInfo($id, $tenantShopId, $executePaymentRequest, $contentType);

        return $response;
    }

    /**
     * executePaymentWithHttpInfo: 決済 実行.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済処理を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\ExecutePaymentRequest $executePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['executePayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExecutePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function executePaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $executePaymentRequest = null, string $contentType = self::contentTypes['executePayment'][0]): array
    {
        $request = $this->executePaymentRequest($id, $tenantShopId, $executePaymentRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExecutePayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExecutePayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExecutePayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExecutePayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExecutePayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * executePaymentAsync: 決済 実行.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済処理を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\ExecutePaymentRequest $executePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['executePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $executePaymentRequest = null, string $contentType = self::contentTypes['executePayment'][0]): PromiseInterface
    {
        return $this->executePaymentAsyncWithHttpInfo($id, $tenantShopId, $executePaymentRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * executePaymentAsyncWithHttpInfo: 決済 実行.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済処理を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\ExecutePaymentRequest $executePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['executePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $executePaymentRequest = null, string $contentType = self::contentTypes['executePayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExecutePayment200Response';
        $request = $this->executePaymentRequest($id, $tenantShopId, $executePaymentRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'executePayment'.
     *
     * @param string                                       $id                    オーダーID（決済情報のID） (required)
     * @param string                                       $tenantShopId          &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済処理を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\ExecutePaymentRequest $executePaymentRequest (optional)
     * @param string                                       $contentType           The value for the Content-Type header. Check self::contentTypes['executePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $executePaymentRequest = null, string $contentType = self::contentTypes['executePayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling executePayment');
        }
        $resourcePath = '/v1/payments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($executePaymentRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($executePaymentRequest));
            } else {
                $httpBody = $executePaymentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * executePaymentAfterThreeDSecureecure: 認証後決済 実行.
     *
     * @param string                                                              $id                                           オーダーID（決済情報のID） (required)
     * @param string                                                              $tenantShopId                                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の3Dセキュア認証後決済を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureRequest $paymentCardExecutingAfterThreeDSecureRequest paymentCardExecutingAfterThreeDSecureRequest (optional)
     * @param string                                                              $contentType                                  The value for the Content-Type header. Check self::contentTypes['executePaymentAfterThreeDSecureecure'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function executePaymentAfterThreeDSecureecure(mixed $id, mixed $tenantShopId = null, mixed $paymentCardExecutingAfterThreeDSecureRequest = null, string $contentType = self::contentTypes['executePaymentAfterThreeDSecureecure'][0]): mixed
    {
        list($response) = $this->executePaymentAfterThreeDSecureecureWithHttpInfo($id, $tenantShopId, $paymentCardExecutingAfterThreeDSecureRequest, $contentType);

        return $response;
    }

    /**
     * executePaymentAfterThreeDSecureecureWithHttpInfo: 認証後決済 実行.
     *
     * @param string                                                              $id                                           オーダーID（決済情報のID） (required)
     * @param string                                                              $tenantShopId                                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の3Dセキュア認証後決済を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureRequest $paymentCardExecutingAfterThreeDSecureRequest (optional)
     * @param string                                                              $contentType                                  The value for the Content-Type header. Check self::contentTypes['executePaymentAfterThreeDSecureecure'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function executePaymentAfterThreeDSecureecureWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentCardExecutingAfterThreeDSecureRequest = null, string $contentType = self::contentTypes['executePaymentAfterThreeDSecureecure'][0]): array
    {
        $request = $this->executePaymentAfterThreeDSecureecureRequest($id, $tenantShopId, $paymentCardExecutingAfterThreeDSecureRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * executePaymentAfterThreeDSecureecureAsync: 認証後決済 実行.
     *
     * @param string                                                              $id                                           オーダーID（決済情報のID） (required)
     * @param string                                                              $tenantShopId                                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の3Dセキュア認証後決済を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureRequest $paymentCardExecutingAfterThreeDSecureRequest (optional)
     * @param string                                                              $contentType                                  The value for the Content-Type header. Check self::contentTypes['executePaymentAfterThreeDSecureecure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentAfterThreeDSecureecureAsync(mixed $id, mixed $tenantShopId = null, mixed $paymentCardExecutingAfterThreeDSecureRequest = null, string $contentType = self::contentTypes['executePaymentAfterThreeDSecureecure'][0]): PromiseInterface
    {
        return $this->executePaymentAfterThreeDSecureecureAsyncWithHttpInfo($id, $tenantShopId, $paymentCardExecutingAfterThreeDSecureRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * executePaymentAfterThreeDSecureecureAsyncWithHttpInfo: 認証後決済 実行.
     *
     * @param string                                                              $id                                           オーダーID（決済情報のID） (required)
     * @param string                                                              $tenantShopId                                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の3Dセキュア認証後決済を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureRequest $paymentCardExecutingAfterThreeDSecureRequest (optional)
     * @param string                                                              $contentType                                  The value for the Content-Type header. Check self::contentTypes['executePaymentAfterThreeDSecureecure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentAfterThreeDSecureecureAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentCardExecutingAfterThreeDSecureRequest = null, string $contentType = self::contentTypes['executePaymentAfterThreeDSecureecure'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureResponse';
        $request = $this->executePaymentAfterThreeDSecureecureRequest($id, $tenantShopId, $paymentCardExecutingAfterThreeDSecureRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'executePaymentAfterThreeDSecureecure'.
     *
     * @param string                                                              $id                                           オーダーID（決済情報のID） (required)
     * @param string                                                              $tenantShopId                                 &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済の3Dセキュア認証後決済を実行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentCardExecutingAfterThreeDSecureRequest $paymentCardExecutingAfterThreeDSecureRequest (optional)
     * @param string                                                              $contentType                                  The value for the Content-Type header. Check self::contentTypes['executePaymentAfterThreeDSecureecure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function executePaymentAfterThreeDSecureecureRequest(mixed $id, mixed $tenantShopId = null, mixed $paymentCardExecutingAfterThreeDSecureRequest = null, string $contentType = self::contentTypes['executePaymentAfterThreeDSecureecure'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling executePaymentAfterThreeDSecureecure');
        }
        $resourcePath = '/v1/payments/{id}/secure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($paymentCardExecutingAfterThreeDSecureRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentCardExecutingAfterThreeDSecureRequest));
            } else {
                $httpBody = $paymentCardExecutingAfterThreeDSecureRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * generateBarcodeOfPayment: バーコード発行.
     *
     * @param string                                                        $id                                     オーダーID（決済情報のID） (required)
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主としたコンビニ決済のうち、&#x60;id&#x60;で指定した決済のバーコードを再度発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeRequest $paymentKonbiniGeneratingBarcodeRequest paymentKonbiniGeneratingBarcodeRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['generateBarcodeOfPayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function generateBarcodeOfPayment(mixed $id, mixed $tenantShopId = null, mixed $paymentKonbiniGeneratingBarcodeRequest = null, string $contentType = self::contentTypes['generateBarcodeOfPayment'][0]): mixed
    {
        list($response) = $this->generateBarcodeOfPaymentWithHttpInfo($id, $tenantShopId, $paymentKonbiniGeneratingBarcodeRequest, $contentType);

        return $response;
    }

    /**
     * generateBarcodeOfPaymentWithHttpInfo: バーコード発行.
     *
     * @param string                                                        $id                                     オーダーID（決済情報のID） (required)
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主としたコンビニ決済のうち、&#x60;id&#x60;で指定した決済のバーコードを再度発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeRequest $paymentKonbiniGeneratingBarcodeRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['generateBarcodeOfPayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function generateBarcodeOfPaymentWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentKonbiniGeneratingBarcodeRequest = null, string $contentType = self::contentTypes['generateBarcodeOfPayment'][0]): array
    {
        $request = $this->generateBarcodeOfPaymentRequest($id, $tenantShopId, $paymentKonbiniGeneratingBarcodeRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * generateBarcodeOfPaymentAsync: バーコード発行.
     *
     * @param string                                                        $id                                     オーダーID（決済情報のID） (required)
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主としたコンビニ決済のうち、&#x60;id&#x60;で指定した決済のバーコードを再度発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeRequest $paymentKonbiniGeneratingBarcodeRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['generateBarcodeOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function generateBarcodeOfPaymentAsync(mixed $id, mixed $tenantShopId = null, mixed $paymentKonbiniGeneratingBarcodeRequest = null, string $contentType = self::contentTypes['generateBarcodeOfPayment'][0]): PromiseInterface
    {
        return $this->generateBarcodeOfPaymentAsyncWithHttpInfo($id, $tenantShopId, $paymentKonbiniGeneratingBarcodeRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * generateBarcodeOfPaymentAsyncWithHttpInfo: バーコード発行.
     *
     * @param string                                                        $id                                     オーダーID（決済情報のID） (required)
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主としたコンビニ決済のうち、&#x60;id&#x60;で指定した決済のバーコードを再度発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeRequest $paymentKonbiniGeneratingBarcodeRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['generateBarcodeOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function generateBarcodeOfPaymentAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $paymentKonbiniGeneratingBarcodeRequest = null, string $contentType = self::contentTypes['generateBarcodeOfPayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeResponse';
        $request = $this->generateBarcodeOfPaymentRequest($id, $tenantShopId, $paymentKonbiniGeneratingBarcodeRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'generateBarcodeOfPayment'.
     *
     * @param string                                                        $id                                     オーダーID（決済情報のID） (required)
     * @param string                                                        $tenantShopId                           &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主としたコンビニ決済のうち、&#x60;id&#x60;で指定した決済のバーコードを再度発行します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaymentKonbiniGeneratingBarcodeRequest $paymentKonbiniGeneratingBarcodeRequest (optional)
     * @param string                                                        $contentType                            The value for the Content-Type header. Check self::contentTypes['generateBarcodeOfPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function generateBarcodeOfPaymentRequest(mixed $id, mixed $tenantShopId = null, mixed $paymentKonbiniGeneratingBarcodeRequest = null, string $contentType = self::contentTypes['generateBarcodeOfPayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling generateBarcodeOfPayment');
        }
        $resourcePath = '/v1/payments/{id}/barcode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($paymentKonbiniGeneratingBarcodeRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentKonbiniGeneratingBarcodeRequest));
            } else {
                $httpBody = $paymentKonbiniGeneratingBarcodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * requestProductionEnvironment: テナントショップ 本番環境申請.
     *
     * @param string $tenantShopId       &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param string $shopId             ショップID (required)
     * @param bool   $enableImmediateUse VISA/Mastercard即時利用をリクエストするかどうか  - &#x60;true&#x60;： 即時利用をリクエストする - &#x60;false&#x60;： 即時利用をリクエストしない  即時利用は以下の場合リクエストできません。  - &#x60;本番環境申請情報.contract_info.site_published&#x60;が&#x60;true&#x60;でない（審査時点でWebサイトが用意されていない） - &#x60;本番環境申請情報.shop_info.deals_long_apply_content&#x60;が&#x60;true&#x60;である（審査に時間がかかる商材を取り扱うと表明している） (required)
     * @param string $contentType        The value for the Content-Type header. Check self::contentTypes['requestProductionEnvironment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\POSTContractsExaminationsResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function requestProductionEnvironment(mixed $tenantShopId, mixed $shopId, mixed $enableImmediateUse, string $contentType = self::contentTypes['requestProductionEnvironment'][0]): mixed
    {
        list($response) = $this->requestProductionEnvironmentWithHttpInfo($tenantShopId, $shopId, $enableImmediateUse, $contentType);

        return $response;
    }

    /**
     * requestProductionEnvironmentWithHttpInfo: テナントショップ 本番環境申請.
     *
     * @param string $tenantShopId       &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param string $shopId             ショップID (required)
     * @param bool   $enableImmediateUse VISA/Mastercard即時利用をリクエストするかどうか  - &#x60;true&#x60;： 即時利用をリクエストする - &#x60;false&#x60;： 即時利用をリクエストしない  即時利用は以下の場合リクエストできません。  - &#x60;本番環境申請情報.contract_info.site_published&#x60;が&#x60;true&#x60;でない（審査時点でWebサイトが用意されていない） - &#x60;本番環境申請情報.shop_info.deals_long_apply_content&#x60;が&#x60;true&#x60;である（審査に時間がかかる商材を取り扱うと表明している） (required)
     * @param string $contentType        The value for the Content-Type header. Check self::contentTypes['requestProductionEnvironment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\POSTContractsExaminationsResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function requestProductionEnvironmentWithHttpInfo(mixed $tenantShopId, mixed $shopId, mixed $enableImmediateUse, string $contentType = self::contentTypes['requestProductionEnvironment'][0]): array
    {
        $request = $this->requestProductionEnvironmentRequest($tenantShopId, $shopId, $enableImmediateUse, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * requestProductionEnvironmentAsync: テナントショップ 本番環境申請.
     *
     * @param string $tenantShopId       &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param string $shopId             ショップID (required)
     * @param bool   $enableImmediateUse VISA/Mastercard即時利用をリクエストするかどうか  - &#x60;true&#x60;： 即時利用をリクエストする - &#x60;false&#x60;： 即時利用をリクエストしない  即時利用は以下の場合リクエストできません。  - &#x60;本番環境申請情報.contract_info.site_published&#x60;が&#x60;true&#x60;でない（審査時点でWebサイトが用意されていない） - &#x60;本番環境申請情報.shop_info.deals_long_apply_content&#x60;が&#x60;true&#x60;である（審査に時間がかかる商材を取り扱うと表明している） (required)
     * @param string $contentType        The value for the Content-Type header. Check self::contentTypes['requestProductionEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function requestProductionEnvironmentAsync(mixed $tenantShopId, mixed $shopId, mixed $enableImmediateUse, string $contentType = self::contentTypes['requestProductionEnvironment'][0]): PromiseInterface
    {
        return $this->requestProductionEnvironmentAsyncWithHttpInfo($tenantShopId, $shopId, $enableImmediateUse, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * requestProductionEnvironmentAsyncWithHttpInfo: テナントショップ 本番環境申請.
     *
     * @param string $tenantShopId       &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param string $shopId             ショップID (required)
     * @param bool   $enableImmediateUse VISA/Mastercard即時利用をリクエストするかどうか  - &#x60;true&#x60;： 即時利用をリクエストする - &#x60;false&#x60;： 即時利用をリクエストしない  即時利用は以下の場合リクエストできません。  - &#x60;本番環境申請情報.contract_info.site_published&#x60;が&#x60;true&#x60;でない（審査時点でWebサイトが用意されていない） - &#x60;本番環境申請情報.shop_info.deals_long_apply_content&#x60;が&#x60;true&#x60;である（審査に時間がかかる商材を取り扱うと表明している） (required)
     * @param string $contentType        The value for the Content-Type header. Check self::contentTypes['requestProductionEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function requestProductionEnvironmentAsyncWithHttpInfo(mixed $tenantShopId, mixed $shopId, mixed $enableImmediateUse, string $contentType = self::contentTypes['requestProductionEnvironment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\POSTContractsExaminationsResponse';
        $request = $this->requestProductionEnvironmentRequest($tenantShopId, $shopId, $enableImmediateUse, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'requestProductionEnvironment'.
     *
     * @param string $tenantShopId       &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param string $shopId             ショップID (required)
     * @param bool   $enableImmediateUse VISA/Mastercard即時利用をリクエストするかどうか  - &#x60;true&#x60;： 即時利用をリクエストする - &#x60;false&#x60;： 即時利用をリクエストしない  即時利用は以下の場合リクエストできません。  - &#x60;本番環境申請情報.contract_info.site_published&#x60;が&#x60;true&#x60;でない（審査時点でWebサイトが用意されていない） - &#x60;本番環境申請情報.shop_info.deals_long_apply_content&#x60;が&#x60;true&#x60;である（審査に時間がかかる商材を取り扱うと表明している） (required)
     * @param string $contentType        The value for the Content-Type header. Check self::contentTypes['requestProductionEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function requestProductionEnvironmentRequest(mixed $tenantShopId, mixed $shopId, mixed $enableImmediateUse, string $contentType = self::contentTypes['requestProductionEnvironment'][0]): Request
    {
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling requestProductionEnvironment');
        }
        // verify the required parameter 'shopId' is set
        if (null === $shopId || is_array($shopId) && 0 === count($shopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $shopId when calling requestProductionEnvironment');
        }
        // verify the required parameter 'enableImmediateUse' is set
        if (null === $enableImmediateUse || is_array($enableImmediateUse) && 0 === count($enableImmediateUse)) {
            throw new \InvalidArgumentException('Missing the required parameter $enableImmediateUse when calling requestProductionEnvironment');
        }
        $resourcePath = '/v1/contracts/examinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // form params
        if (null !== $shopId) {
            $formParams['shop_id'] = ObjectSerializer::toFormValue($shopId);
        }
        // form params
        if (null !== $enableImmediateUse) {
            $formParams['enable_immediate_use'] = ObjectSerializer::toFormValue($enableImmediateUse);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * reserveProvider: テナントショップ 決済手段追加申請.
     *
     * @param string                                   $id           指定したテナントショップに対して決済手段を追加申請します。。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに対して決済手段を追加申請します。 (required)
     * @param \OpenAPI\Fincode\Model\PaymentProvider[] $provider     追加対象決済手段\\\\ \\\\ 追加で申請する決済手段をリストで指定します。  - &#x60;PAYSLE&#x60;: コンビニ決済 - &#x60;PAYPAY&#x60;: \OpenAPI\Fincode\Model\PayPay - &#x60;APPLE_PAY_UC&#x60;: Apple Pay（VISA/Mastercard） - &#x60;APPLE_PAY_JCB&#x60;: Apple Pay（JCB/American Express/Diners Club） - &#x60;DIRECT_DEBIT&#x60;: 口座振替 - &#x60;VIRTUAL_ACCOUNT&#x60;: 銀行振込（バーチャル口座） (required)
     * @param string                                   $contentType  The value for the Content-Type header. Check self::contentTypes['reserveProvider'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\POSTProviderReserveResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function reserveProvider(mixed $id, mixed $tenantShopId, mixed $provider, string $contentType = self::contentTypes['reserveProvider'][0]): mixed
    {
        list($response) = $this->reserveProviderWithHttpInfo($id, $tenantShopId, $provider, $contentType);

        return $response;
    }

    /**
     * reserveProviderWithHttpInfo: テナントショップ 決済手段追加申請.
     *
     * @param string                                   $id           指定したテナントショップに対して決済手段を追加申請します。。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに対して決済手段を追加申請します。 (required)
     * @param \OpenAPI\Fincode\Model\PaymentProvider[] $provider     追加対象決済手段\\\\ \\\\ 追加で申請する決済手段をリストで指定します。  - &#x60;PAYSLE&#x60;: コンビニ決済 - &#x60;PAYPAY&#x60;: \OpenAPI\Fincode\Model\PayPay - &#x60;APPLE_PAY_UC&#x60;: Apple Pay（VISA/Mastercard） - &#x60;APPLE_PAY_JCB&#x60;: Apple Pay（JCB/American Express/Diners Club） - &#x60;DIRECT_DEBIT&#x60;: 口座振替 - &#x60;VIRTUAL_ACCOUNT&#x60;: 銀行振込（バーチャル口座） (required)
     * @param string                                   $contentType  The value for the Content-Type header. Check self::contentTypes['reserveProvider'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\POSTProviderReserveResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function reserveProviderWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $provider, string $contentType = self::contentTypes['reserveProvider'][0]): array
    {
        $request = $this->reserveProviderRequest($id, $tenantShopId, $provider, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\POSTProviderReserveResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\POSTProviderReserveResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\POSTProviderReserveResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\POSTProviderReserveResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\POSTProviderReserveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * reserveProviderAsync: テナントショップ 決済手段追加申請.
     *
     * @param string                                   $id           指定したテナントショップに対して決済手段を追加申請します。。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに対して決済手段を追加申請します。 (required)
     * @param \OpenAPI\Fincode\Model\PaymentProvider[] $provider     追加対象決済手段\\\\ \\\\ 追加で申請する決済手段をリストで指定します。  - &#x60;PAYSLE&#x60;: コンビニ決済 - &#x60;PAYPAY&#x60;: \OpenAPI\Fincode\Model\PayPay - &#x60;APPLE_PAY_UC&#x60;: Apple Pay（VISA/Mastercard） - &#x60;APPLE_PAY_JCB&#x60;: Apple Pay（JCB/American Express/Diners Club） - &#x60;DIRECT_DEBIT&#x60;: 口座振替 - &#x60;VIRTUAL_ACCOUNT&#x60;: 銀行振込（バーチャル口座） (required)
     * @param string                                   $contentType  The value for the Content-Type header. Check self::contentTypes['reserveProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function reserveProviderAsync(mixed $id, mixed $tenantShopId, mixed $provider, string $contentType = self::contentTypes['reserveProvider'][0]): PromiseInterface
    {
        return $this->reserveProviderAsyncWithHttpInfo($id, $tenantShopId, $provider, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * reserveProviderAsyncWithHttpInfo: テナントショップ 決済手段追加申請.
     *
     * @param string                                   $id           指定したテナントショップに対して決済手段を追加申請します。。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに対して決済手段を追加申請します。 (required)
     * @param \OpenAPI\Fincode\Model\PaymentProvider[] $provider     追加対象決済手段\\\\ \\\\ 追加で申請する決済手段をリストで指定します。  - &#x60;PAYSLE&#x60;: コンビニ決済 - &#x60;PAYPAY&#x60;: \OpenAPI\Fincode\Model\PayPay - &#x60;APPLE_PAY_UC&#x60;: Apple Pay（VISA/Mastercard） - &#x60;APPLE_PAY_JCB&#x60;: Apple Pay（JCB/American Express/Diners Club） - &#x60;DIRECT_DEBIT&#x60;: 口座振替 - &#x60;VIRTUAL_ACCOUNT&#x60;: 銀行振込（バーチャル口座） (required)
     * @param string                                   $contentType  The value for the Content-Type header. Check self::contentTypes['reserveProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function reserveProviderAsyncWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $provider, string $contentType = self::contentTypes['reserveProvider'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\POSTProviderReserveResponse';
        $request = $this->reserveProviderRequest($id, $tenantShopId, $provider, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'reserveProvider'.
     *
     * @param string                                   $id           指定したテナントショップに対して決済手段を追加申請します。。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップに対して決済手段を追加申請します。 (required)
     * @param \OpenAPI\Fincode\Model\PaymentProvider[] $provider     追加対象決済手段\\\\ \\\\ 追加で申請する決済手段をリストで指定します。  - &#x60;PAYSLE&#x60;: コンビニ決済 - &#x60;PAYPAY&#x60;: \OpenAPI\Fincode\Model\PayPay - &#x60;APPLE_PAY_UC&#x60;: Apple Pay（VISA/Mastercard） - &#x60;APPLE_PAY_JCB&#x60;: Apple Pay（JCB/American Express/Diners Club） - &#x60;DIRECT_DEBIT&#x60;: 口座振替 - &#x60;VIRTUAL_ACCOUNT&#x60;: 銀行振込（バーチャル口座） (required)
     * @param string                                   $contentType  The value for the Content-Type header. Check self::contentTypes['reserveProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function reserveProviderRequest(mixed $id, mixed $tenantShopId, mixed $provider, string $contentType = self::contentTypes['reserveProvider'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling reserveProvider');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling reserveProvider');
        }
        // verify the required parameter 'provider' is set
        if (null === $provider || is_array($provider) && 0 === count($provider)) {
            throw new \InvalidArgumentException('Missing the required parameter $provider when calling reserveProvider');
        }
        $resourcePath = '/v1/contracts/examinations/tenants/{id}/providers/reserve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        // form params
        if (null !== $provider) {
            $formParams['provider'] = ObjectSerializer::toFormValue($provider);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveAccount: 売上入金 取得.
     *
     * @param string $id           売上入金ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccount'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\AccountRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccount(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveAccount'][0]): mixed
    {
        list($response) = $this->retrieveAccountWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveAccountWithHttpInfo: 売上入金 取得.
     *
     * @param string $id           売上入金ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccount'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\AccountRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveAccount'][0]): array
    {
        $request = $this->retrieveAccountRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\AccountRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\AccountRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\AccountRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\AccountRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\AccountRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveAccountAsync: 売上入金 取得.
     *
     * @param string $id           売上入金ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveAccount'][0]): PromiseInterface
    {
        return $this->retrieveAccountAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveAccountAsyncWithHttpInfo: 売上入金 取得.
     *
     * @param string $id           売上入金ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveAccount'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\AccountRetrievingResponse';
        $request = $this->retrieveAccountRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveAccount'.
     *
     * @param string $id           売上入金ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveAccount'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveAccount');
        }
        $resourcePath = '/v1/accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveAccountDetailList: 売上入金詳細 一覧取得.
     *
     * @param string                                       $id           売上入金ID (required)
     * @param string                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報の売上入金詳細を取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaginationQueryParams $query        売上入金詳細の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountDetailList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountDetailList(mixed $id, mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountDetailList'][0]): mixed
    {
        list($response) = $this->retrieveAccountDetailListWithHttpInfo($id, $tenantShopId, $query, $contentType);

        return $response;
    }

    /**
     * retrieveAccountDetailListWithHttpInfo: 売上入金詳細 一覧取得.
     *
     * @param string                                       $id           売上入金ID (required)
     * @param string                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報の売上入金詳細を取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaginationQueryParams $query        売上入金詳細の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountDetailList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountDetailListWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountDetailList'][0]): array
    {
        $request = $this->retrieveAccountDetailListRequest($id, $tenantShopId, $query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveAccountDetailListAsync: 売上入金詳細 一覧取得.
     *
     * @param string                                       $id           売上入金ID (required)
     * @param string                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報の売上入金詳細を取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaginationQueryParams $query        売上入金詳細の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountDetailListAsync(mixed $id, mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountDetailList'][0]): PromiseInterface
    {
        return $this->retrieveAccountDetailListAsyncWithHttpInfo($id, $tenantShopId, $query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveAccountDetailListAsyncWithHttpInfo: 売上入金詳細 一覧取得.
     *
     * @param string                                       $id           売上入金ID (required)
     * @param string                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報の売上入金詳細を取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaginationQueryParams $query        売上入金詳細の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountDetailListAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountDetailList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\AccountDetailListRetrievingResponse';
        $request = $this->retrieveAccountDetailListRequest($id, $tenantShopId, $query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveAccountDetailList'.
     *
     * @param string                                       $id           売上入金ID (required)
     * @param string                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報のうち、指定したIDの売上入金情報の売上入金詳細を取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\PaginationQueryParams $query        売上入金詳細の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountDetailListRequest(mixed $id, mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountDetailList'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveAccountDetailList');
        }
        $resourcePath = '/v1/accounts/{id}/detail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveAccountList: 売上入金 一覧取得.
     *
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報から一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrieveAccountListQueryParameter $query        売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\AccountListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountList(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountList'][0]): mixed
    {
        list($response) = $this->retrieveAccountListWithHttpInfo($tenantShopId, $query, $contentType);

        return $response;
    }

    /**
     * retrieveAccountListWithHttpInfo: 売上入金 一覧取得.
     *
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報から一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrieveAccountListQueryParameter $query        売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\AccountListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountListWithHttpInfo(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountList'][0]): array
    {
        $request = $this->retrieveAccountListRequest($tenantShopId, $query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\AccountListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\AccountListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\AccountListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\AccountListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\AccountListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveAccountListAsync: 売上入金 一覧取得.
     *
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報から一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrieveAccountListQueryParameter $query        売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountListAsync(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountList'][0]): PromiseInterface
    {
        return $this->retrieveAccountListAsyncWithHttpInfo($tenantShopId, $query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveAccountListAsyncWithHttpInfo: 売上入金 一覧取得.
     *
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報から一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrieveAccountListQueryParameter $query        売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountListAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\AccountListRetrievingResponse';
        $request = $this->retrieveAccountListRequest($tenantShopId, $query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveAccountList'.
     *
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップの売上入金情報から一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrieveAccountListQueryParameter $query        売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveAccountListRequest(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrieveAccountList'][0]): Request
    {
        $resourcePath = '/v1/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomer: 顧客 取得.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomer'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomer(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomer'][0]): mixed
    {
        list($response) = $this->retrieveCustomerWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerWithHttpInfo: 顧客 取得.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomer'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomer'][0]): array
    {
        $request = $this->retrieveCustomerRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerAsync: 顧客 取得.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerAsync(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomer'][0]): PromiseInterface
    {
        return $this->retrieveCustomerAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerAsyncWithHttpInfo: 顧客 取得.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomer'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerRetrievingResponse';
        $request = $this->retrieveCustomerRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomer'.
     *
     * @param string $id           顧客ID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerRequest(mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomer'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveCustomer');
        }
        $resourcePath = '/v1/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomerCard: カード 取得.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           取得するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードから取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCard'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCardRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCard(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCard'][0]): mixed
    {
        list($response) = $this->retrieveCustomerCardWithHttpInfo($customerId, $id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerCardWithHttpInfo: カード 取得.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           取得するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードから取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCard'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCardRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCard'][0]): array
    {
        $request = $this->retrieveCustomerCardRequest($customerId, $id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerCardAsync: カード 取得.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           取得するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードから取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardAsync(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCard'][0]): PromiseInterface
    {
        return $this->retrieveCustomerCardAsyncWithHttpInfo($customerId, $id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerCardAsyncWithHttpInfo: カード 取得.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           取得するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードから取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardAsyncWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCard'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCardRetrievingResponse';
        $request = $this->retrieveCustomerCardRequest($customerId, $id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomerCard'.
     *
     * @param string $customerId   このカードが紐づく顧客のID (required)
     * @param string $id           取得するカードのID (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードから取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardRequest(mixed $customerId, mixed $id, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCard'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling retrieveCustomerCard');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveCustomerCard');
        }
        $resourcePath = '/v1/customers/{customer_id}/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomerCardList: カード 一覧取得.
     *
     * @param string $customerId   顧客ID。 \\ この顧客に紐づくカードを一覧で取得します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの一覧を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCardList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardList(mixed $customerId, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCardList'][0]): mixed
    {
        list($response) = $this->retrieveCustomerCardListWithHttpInfo($customerId, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerCardListWithHttpInfo: カード 一覧取得.
     *
     * @param string $customerId   顧客ID。 \\ この顧客に紐づくカードを一覧で取得します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの一覧を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCardList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardListWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCardList'][0]): array
    {
        $request = $this->retrieveCustomerCardListRequest($customerId, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerCardListAsync: カード 一覧取得.
     *
     * @param string $customerId   顧客ID。 \\ この顧客に紐づくカードを一覧で取得します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの一覧を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCardList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardListAsync(mixed $customerId, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCardList'][0]): PromiseInterface
    {
        return $this->retrieveCustomerCardListAsyncWithHttpInfo($customerId, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerCardListAsyncWithHttpInfo: カード 一覧取得.
     *
     * @param string $customerId   顧客ID。 \\ この顧客に紐づくカードを一覧で取得します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの一覧を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCardList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardListAsyncWithHttpInfo(mixed $customerId, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCardList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCardListRetrievingResponse';
        $request = $this->retrieveCustomerCardListRequest($customerId, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomerCardList'.
     *
     * @param string $customerId   顧客ID。 \\ この顧客に紐づくカードを一覧で取得します。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの一覧を取得します。 (optional)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerCardList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerCardListRequest(mixed $customerId, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerCardList'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling retrieveCustomerCardList');
        }
        $resourcePath = '/v1/customers/{customer_id}/cards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomerList: 顧客 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveCustomerListQueryParameter $query        顧客情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                    $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客から一覧で取得します。 (optional)
     * @param string                                                    $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerList(mixed $query = null, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerList'][0]): mixed
    {
        list($response) = $this->retrieveCustomerListWithHttpInfo($query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerListWithHttpInfo: 顧客 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveCustomerListQueryParameter $query        顧客情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                    $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客から一覧で取得します。 (optional)
     * @param string                                                    $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerListWithHttpInfo(mixed $query = null, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerList'][0]): array
    {
        $request = $this->retrieveCustomerListRequest($query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerListAsync: 顧客 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveCustomerListQueryParameter $query        顧客情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                    $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客から一覧で取得します。 (optional)
     * @param string                                                    $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerListAsync(mixed $query = null, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerList'][0]): PromiseInterface
    {
        return $this->retrieveCustomerListAsyncWithHttpInfo($query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerListAsyncWithHttpInfo: 顧客 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveCustomerListQueryParameter $query        顧客情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                    $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客から一覧で取得します。 (optional)
     * @param string                                                    $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerListAsyncWithHttpInfo(mixed $query = null, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerListRetrievingResponse';
        $request = $this->retrieveCustomerListRequest($query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomerList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveCustomerListQueryParameter $query        顧客情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                    $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客から一覧で取得します。 (optional)
     * @param string                                                    $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerListRequest(mixed $query = null, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerList'][0]): Request
    {
        $resourcePath = '/v1/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomerPaymentMethod: 決済手段 取得.
     *
     * @param string                                                            $customerId   顧客ID (required)
     * @param string                                                            $id           決済手段ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingQueryParams $query        決済手段の取得において検索条件となるクエリパラメータ (required)
     * @param string                                                            $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を取得します。 (optional)
     * @param string                                                            $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethod(mixed $customerId, mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethod'][0]): mixed
    {
        list($response) = $this->retrieveCustomerPaymentMethodWithHttpInfo($customerId, $id, $query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerPaymentMethodWithHttpInfo: 決済手段 取得.
     *
     * @param string                                                            $customerId   顧客ID (required)
     * @param string                                                            $id           決済手段ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingQueryParams $query        決済手段の取得において検索条件となるクエリパラメータ (required)
     * @param string                                                            $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を取得します。 (optional)
     * @param string                                                            $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodWithHttpInfo(mixed $customerId, mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethod'][0]): array
    {
        $request = $this->retrieveCustomerPaymentMethodRequest($customerId, $id, $query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerPaymentMethodAsync: 決済手段 取得.
     *
     * @param string                                                            $customerId   顧客ID (required)
     * @param string                                                            $id           決済手段ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingQueryParams $query        決済手段の取得において検索条件となるクエリパラメータ (required)
     * @param string                                                            $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を取得します。 (optional)
     * @param string                                                            $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodAsync(mixed $customerId, mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethod'][0]): PromiseInterface
    {
        return $this->retrieveCustomerPaymentMethodAsyncWithHttpInfo($customerId, $id, $query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerPaymentMethodAsyncWithHttpInfo: 決済手段 取得.
     *
     * @param string                                                            $customerId   顧客ID (required)
     * @param string                                                            $id           決済手段ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingQueryParams $query        決済手段の取得において検索条件となるクエリパラメータ (required)
     * @param string                                                            $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を取得します。 (optional)
     * @param string                                                            $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodAsyncWithHttpInfo(mixed $customerId, mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethod'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingResponse';
        $request = $this->retrieveCustomerPaymentMethodRequest($customerId, $id, $query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomerPaymentMethod'.
     *
     * @param string                                                            $customerId   顧客ID (required)
     * @param string                                                            $id           決済手段ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodRetrievingQueryParams $query        決済手段の取得において検索条件となるクエリパラメータ (required)
     * @param string                                                            $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段からIDで指定した決済手段を取得します。 (optional)
     * @param string                                                            $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodRequest(mixed $customerId, mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethod'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling retrieveCustomerPaymentMethod');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveCustomerPaymentMethod');
        }
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrieveCustomerPaymentMethod');
        }
        $resourcePath = '/v1/customers/{customer_id}/payment_methods/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'CustomerPaymentMethodRetrievingQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveCustomerPaymentMethodList: 決済手段 一覧取得.
     *
     * @param string                                                                $customerId   顧客ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingQueryParams $query        決済手段の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                                $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段から一覧で取得します。 (optional)
     * @param string                                                                $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethodList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodList(mixed $customerId, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethodList'][0]): mixed
    {
        list($response) = $this->retrieveCustomerPaymentMethodListWithHttpInfo($customerId, $query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveCustomerPaymentMethodListWithHttpInfo: 決済手段 一覧取得.
     *
     * @param string                                                                $customerId   顧客ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingQueryParams $query        決済手段の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                                $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段から一覧で取得します。 (optional)
     * @param string                                                                $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethodList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodListWithHttpInfo(mixed $customerId, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethodList'][0]): array
    {
        $request = $this->retrieveCustomerPaymentMethodListRequest($customerId, $query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveCustomerPaymentMethodListAsync: 決済手段 一覧取得.
     *
     * @param string                                                                $customerId   顧客ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingQueryParams $query        決済手段の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                                $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段から一覧で取得します。 (optional)
     * @param string                                                                $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethodList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodListAsync(mixed $customerId, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethodList'][0]): PromiseInterface
    {
        return $this->retrieveCustomerPaymentMethodListAsyncWithHttpInfo($customerId, $query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveCustomerPaymentMethodListAsyncWithHttpInfo: 決済手段 一覧取得.
     *
     * @param string                                                                $customerId   顧客ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingQueryParams $query        決済手段の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                                $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段から一覧で取得します。 (optional)
     * @param string                                                                $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethodList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodListAsyncWithHttpInfo(mixed $customerId, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethodList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingResponse';
        $request = $this->retrieveCustomerPaymentMethodListRequest($customerId, $query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveCustomerPaymentMethodList'.
     *
     * @param string                                                                $customerId   顧客ID (required)
     * @param \OpenAPI\Fincode\Model\CustomerPaymentMethodListRetrievingQueryParams $query        決済手段の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                                $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に紐づく決済手段から一覧で取得します。 (optional)
     * @param string                                                                $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveCustomerPaymentMethodList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveCustomerPaymentMethodListRequest(mixed $customerId, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrieveCustomerPaymentMethodList'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling retrieveCustomerPaymentMethodList');
        }
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrieveCustomerPaymentMethodList');
        }
        $resourcePath = '/v1/customers/{customer_id}/payment_methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'CustomerPaymentMethodListRetrievingQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePayment: 決済 取得.
     *
     * @param string                                              $id           オーダーID（決済情報のID） (required)
     * @param \OpenAPI\Fincode\Model\PaymentRetrievingQueryParams $query        決済の取得において検索条件となるクエリパラメータ (required)
     * @param string                                              $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済情報を取得します。 (optional)
     * @param string                                              $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePayment'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\RetrievePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePayment(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePayment'][0]): mixed
    {
        list($response) = $this->retrievePaymentWithHttpInfo($id, $query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrievePaymentWithHttpInfo: 決済 取得.
     *
     * @param string                                              $id           オーダーID（決済情報のID） (required)
     * @param \OpenAPI\Fincode\Model\PaymentRetrievingQueryParams $query        決済の取得において検索条件となるクエリパラメータ (required)
     * @param string                                              $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済情報を取得します。 (optional)
     * @param string                                              $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePayment'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\RetrievePayment200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentWithHttpInfo(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePayment'][0]): array
    {
        $request = $this->retrievePaymentRequest($id, $query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\RetrievePayment200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\RetrievePayment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\RetrievePayment200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\RetrievePayment200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\RetrievePayment200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePaymentAsync: 決済 取得.
     *
     * @param string                                              $id           オーダーID（決済情報のID） (required)
     * @param \OpenAPI\Fincode\Model\PaymentRetrievingQueryParams $query        決済の取得において検索条件となるクエリパラメータ (required)
     * @param string                                              $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済情報を取得します。 (optional)
     * @param string                                              $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentAsync(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePayment'][0]): PromiseInterface
    {
        return $this->retrievePaymentAsyncWithHttpInfo($id, $query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePaymentAsyncWithHttpInfo: 決済 取得.
     *
     * @param string                                              $id           オーダーID（決済情報のID） (required)
     * @param \OpenAPI\Fincode\Model\PaymentRetrievingQueryParams $query        決済の取得において検索条件となるクエリパラメータ (required)
     * @param string                                              $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済情報を取得します。 (optional)
     * @param string                                              $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentAsyncWithHttpInfo(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePayment'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\RetrievePayment200Response';
        $request = $this->retrievePaymentRequest($id, $query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePayment'.
     *
     * @param string                                              $id           オーダーID（決済情報のID） (required)
     * @param \OpenAPI\Fincode\Model\PaymentRetrievingQueryParams $query        決済の取得において検索条件となるクエリパラメータ (required)
     * @param string                                              $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした決済のうち、&#x60;id&#x60;で指定した決済情報を取得します。 (optional)
     * @param string                                              $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentRequest(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePayment'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePayment');
        }
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrievePayment');
        }
        $resourcePath = '/v1/payments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaymentRetrievingQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePaymentBulkDetailList: 一括決済詳細 一覧取得.
     *
     * @param string                                                             $id           一括決済ID。\\ 詳細を取得する一括決済情報のIDを指定します。 (required)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkDetailListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                             $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済の詳細を一覧で取得します。 (optional)
     * @param string                                                             $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkDetailList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkDetailList(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentBulkDetailList'][0]): mixed
    {
        list($response) = $this->retrievePaymentBulkDetailListWithHttpInfo($id, $query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrievePaymentBulkDetailListWithHttpInfo: 一括決済詳細 一覧取得.
     *
     * @param string                                                             $id           一括決済ID。\\ 詳細を取得する一括決済情報のIDを指定します。 (required)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkDetailListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                             $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済の詳細を一覧で取得します。 (optional)
     * @param string                                                             $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkDetailList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkDetailListWithHttpInfo(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentBulkDetailList'][0]): array
    {
        $request = $this->retrievePaymentBulkDetailListRequest($id, $query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePaymentBulkDetailListAsync: 一括決済詳細 一覧取得.
     *
     * @param string                                                             $id           一括決済ID。\\ 詳細を取得する一括決済情報のIDを指定します。 (required)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkDetailListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                             $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済の詳細を一覧で取得します。 (optional)
     * @param string                                                             $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkDetailListAsync(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentBulkDetailList'][0]): PromiseInterface
    {
        return $this->retrievePaymentBulkDetailListAsyncWithHttpInfo($id, $query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePaymentBulkDetailListAsyncWithHttpInfo: 一括決済詳細 一覧取得.
     *
     * @param string                                                             $id           一括決済ID。\\ 詳細を取得する一括決済情報のIDを指定します。 (required)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkDetailListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                             $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済の詳細を一覧で取得します。 (optional)
     * @param string                                                             $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkDetailListAsyncWithHttpInfo(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentBulkDetailList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentBulkDetailListRetrievingResponse';
        $request = $this->retrievePaymentBulkDetailListRequest($id, $query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePaymentBulkDetailList'.
     *
     * @param string                                                             $id           一括決済ID。\\ 詳細を取得する一括決済情報のIDを指定します。 (required)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkDetailListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                             $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済の詳細を一覧で取得します。 (optional)
     * @param string                                                             $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkDetailList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkDetailListRequest(mixed $id, mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentBulkDetailList'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePaymentBulkDetailList');
        }
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrievePaymentBulkDetailList');
        }
        $resourcePath = '/v1/payments/bulk/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePaymentBulkList: 一括決済 一覧取得.
     *
     * @param string                                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkList(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrievePaymentBulkList'][0]): mixed
    {
        list($response) = $this->retrievePaymentBulkListWithHttpInfo($tenantShopId, $query, $contentType);

        return $response;
    }

    /**
     * retrievePaymentBulkListWithHttpInfo: 一括決済 一覧取得.
     *
     * @param string                                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkListWithHttpInfo(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrievePaymentBulkList'][0]): array
    {
        $request = $this->retrievePaymentBulkListRequest($tenantShopId, $query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePaymentBulkListAsync: 一括決済 一覧取得.
     *
     * @param string                                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkListAsync(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrievePaymentBulkList'][0]): PromiseInterface
    {
        return $this->retrievePaymentBulkListAsyncWithHttpInfo($tenantShopId, $query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePaymentBulkListAsyncWithHttpInfo: 一括決済 一覧取得.
     *
     * @param string                                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkListAsyncWithHttpInfo(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrievePaymentBulkList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PaymentBulkListRetrievingResponse';
        $request = $this->retrievePaymentBulkListRequest($tenantShopId, $query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePaymentBulkList'.
     *
     * @param string                                                       $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップを販売主とした一括決済情報を一覧で取得します。 (optional)
     * @param \OpenAPI\Fincode\Model\RetrievePaymentBulkListQueryParameter $query        一括決済情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                       $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentBulkList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentBulkListRequest(mixed $tenantShopId = null, mixed $query = null, string $contentType = self::contentTypes['retrievePaymentBulkList'][0]): Request
    {
        $resourcePath = '/v1/payments/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePaymentList: 決済 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePaymentListQueryParameter $query        決済の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく決済から一覧で取得します。 (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\RetrievePaymentList200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentList(mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentList'][0]): mixed
    {
        list($response) = $this->retrievePaymentListWithHttpInfo($query, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrievePaymentListWithHttpInfo: 決済 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePaymentListQueryParameter $query        決済の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく決済から一覧で取得します。 (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\RetrievePaymentList200Response|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentListWithHttpInfo(mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentList'][0]): array
    {
        $request = $this->retrievePaymentListRequest($query, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\RetrievePaymentList200Response' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\RetrievePaymentList200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\RetrievePaymentList200Response', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\RetrievePaymentList200Response';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\RetrievePaymentList200Response', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePaymentListAsync: 決済 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePaymentListQueryParameter $query        決済の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく決済から一覧で取得します。 (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentListAsync(mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentList'][0]): PromiseInterface
    {
        return $this->retrievePaymentListAsyncWithHttpInfo($query, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePaymentListAsyncWithHttpInfo: 決済 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePaymentListQueryParameter $query        決済の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく決済から一覧で取得します。 (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentListAsyncWithHttpInfo(mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\RetrievePaymentList200Response';
        $request = $this->retrievePaymentListRequest($query, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePaymentList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePaymentListQueryParameter $query        決済の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                   $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく決済から一覧で取得します。 (optional)
     * @param string                                                   $contentType  The value for the Content-Type header. Check self::contentTypes['retrievePaymentList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePaymentListRequest(mixed $query, mixed $tenantShopId = null, string $contentType = self::contentTypes['retrievePaymentList'][0]): Request
    {
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrievePaymentList');
        }
        $resourcePath = '/v1/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'OneOfRetrievePaymentListQueryParameterOneOfApplePayRetrievePaymentListQueryParameterOneOf1PayPayRetrievePaymentListQueryParameterOneOf2RetrievePaymentListQueryParameterOneOf3',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlan: プラン 取得.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlan'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlanRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlan(mixed $id, string $contentType = self::contentTypes['retrievePlan'][0]): mixed
    {
        list($response) = $this->retrievePlanWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * retrievePlanWithHttpInfo: プラン 取得.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlan'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlanRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlanWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlan'][0]): array
    {
        $request = $this->retrievePlanRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlanRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlanRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlanRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlanRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlanRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlanAsync: プラン 取得.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanAsync(mixed $id, string $contentType = self::contentTypes['retrievePlan'][0]): PromiseInterface
    {
        return $this->retrievePlanAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlanAsyncWithHttpInfo: プラン 取得.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlan'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlanRetrievingResponse';
        $request = $this->retrievePlanRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlan'.
     *
     * @param string $id          プランID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanRequest(mixed $id, string $contentType = self::contentTypes['retrievePlan'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePlan');
        }
        $resourcePath = '/v1/plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlanList: プラン 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlanListQueryParameter $query       プラン情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlanList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlanListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlanList(mixed $query = null, string $contentType = self::contentTypes['retrievePlanList'][0]): mixed
    {
        list($response) = $this->retrievePlanListWithHttpInfo($query, $contentType);

        return $response;
    }

    /**
     * retrievePlanListWithHttpInfo: プラン 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlanListQueryParameter $query       プラン情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlanList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlanListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlanListWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlanList'][0]): array
    {
        $request = $this->retrievePlanListRequest($query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlanListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlanListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlanListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlanListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlanListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlanListAsync: プラン 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlanListQueryParameter $query       プラン情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlanList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanListAsync(mixed $query = null, string $contentType = self::contentTypes['retrievePlanList'][0]): PromiseInterface
    {
        return $this->retrievePlanListAsyncWithHttpInfo($query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlanListAsyncWithHttpInfo: プラン 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlanListQueryParameter $query       プラン情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlanList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanListAsyncWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlanList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlanListRetrievingResponse';
        $request = $this->retrievePlanListRequest($query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlanList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlanListQueryParameter $query       プラン情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlanList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlanListRequest(mixed $query = null, string $contentType = self::contentTypes['retrievePlanList'][0]): Request
    {
        $resourcePath = '/v1/plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlatformAccount: プラットフォーム利用料収入 取得.
     *
     * @param string $id          プラットフォーム利用料収入ID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccount'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccount(mixed $id, string $contentType = self::contentTypes['retrievePlatformAccount'][0]): mixed
    {
        list($response) = $this->retrievePlatformAccountWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * retrievePlatformAccountWithHttpInfo: プラットフォーム利用料収入 取得.
     *
     * @param string $id          プラットフォーム利用料収入ID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccount'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlatformAccount'][0]): array
    {
        $request = $this->retrievePlatformAccountRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlatformAccountAsync: プラットフォーム利用料収入 取得.
     *
     * @param string $id          プラットフォーム利用料収入ID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountAsync(mixed $id, string $contentType = self::contentTypes['retrievePlatformAccount'][0]): PromiseInterface
    {
        return $this->retrievePlatformAccountAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlatformAccountAsyncWithHttpInfo: プラットフォーム利用料収入 取得.
     *
     * @param string $id          プラットフォーム利用料収入ID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlatformAccount'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformAccountRetrievingResponse';
        $request = $this->retrievePlatformAccountRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlatformAccount'.
     *
     * @param string $id          プラットフォーム利用料収入ID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountRequest(mixed $id, string $contentType = self::contentTypes['retrievePlatformAccount'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePlatformAccount');
        }
        $resourcePath = '/v1/platform_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlatformAccountList: プラットフォーム利用料収入 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                           $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountList(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountList'][0]): mixed
    {
        list($response) = $this->retrievePlatformAccountListWithHttpInfo($query, $contentType);

        return $response;
    }

    /**
     * retrievePlatformAccountListWithHttpInfo: プラットフォーム利用料収入 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                           $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountListWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountList'][0]): array
    {
        $request = $this->retrievePlatformAccountListRequest($query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlatformAccountListAsync: プラットフォーム利用料収入 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                           $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountListAsync(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountList'][0]): PromiseInterface
    {
        return $this->retrievePlatformAccountListAsyncWithHttpInfo($query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlatformAccountListAsyncWithHttpInfo: プラットフォーム利用料収入 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                           $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountListAsyncWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformAccountListRetrievingResponse';
        $request = $this->retrievePlatformAccountListRequest($query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlatformAccountList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                           $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountListRequest(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountList'][0]): Request
    {
        $resourcePath = '/v1/platform_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlatformAccountSummaryList: プラットフォーム利用料収入サマリー 一覧取得.
     *
     * @param string                                                                  $id          プラットフォーム利用料収入ID (required)
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountSummaryListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                                  $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountSummaryList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountSummaryList(mixed $id, mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountSummaryList'][0]): mixed
    {
        list($response) = $this->retrievePlatformAccountSummaryListWithHttpInfo($id, $query, $contentType);

        return $response;
    }

    /**
     * retrievePlatformAccountSummaryListWithHttpInfo: プラットフォーム利用料収入サマリー 一覧取得.
     *
     * @param string                                                                  $id          プラットフォーム利用料収入ID (required)
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountSummaryListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                                  $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountSummaryList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountSummaryListWithHttpInfo(mixed $id, mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountSummaryList'][0]): array
    {
        $request = $this->retrievePlatformAccountSummaryListRequest($id, $query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlatformAccountSummaryListAsync: プラットフォーム利用料収入サマリー 一覧取得.
     *
     * @param string                                                                  $id          プラットフォーム利用料収入ID (required)
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountSummaryListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                                  $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountSummaryList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountSummaryListAsync(mixed $id, mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountSummaryList'][0]): PromiseInterface
    {
        return $this->retrievePlatformAccountSummaryListAsyncWithHttpInfo($id, $query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlatformAccountSummaryListAsyncWithHttpInfo: プラットフォーム利用料収入サマリー 一覧取得.
     *
     * @param string                                                                  $id          プラットフォーム利用料収入ID (required)
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountSummaryListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                                  $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountSummaryList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountSummaryListAsyncWithHttpInfo(mixed $id, mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountSummaryList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformAccountSummaryListRetrievingResponse';
        $request = $this->retrievePlatformAccountSummaryListRequest($id, $query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlatformAccountSummaryList'.
     *
     * @param string                                                                  $id          プラットフォーム利用料収入ID (required)
     * @param \OpenAPI\Fincode\Model\RetrievePlatformAccountSummaryListQueryParameter $query       プラットフォーム利用料による売上入金情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                                  $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformAccountSummaryList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformAccountSummaryListRequest(mixed $id, mixed $query = null, string $contentType = self::contentTypes['retrievePlatformAccountSummaryList'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePlatformAccountSummaryList');
        }
        $resourcePath = '/v1/platform_accounts/{id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlatformShop: プラットフォームショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShop'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformShopRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShop(mixed $id, string $contentType = self::contentTypes['retrievePlatformShop'][0]): mixed
    {
        list($response) = $this->retrievePlatformShopWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * retrievePlatformShopWithHttpInfo: プラットフォームショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShop'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformShopRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlatformShop'][0]): array
    {
        $request = $this->retrievePlatformShopRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlatformShopAsync: プラットフォームショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopAsync(mixed $id, string $contentType = self::contentTypes['retrievePlatformShop'][0]): PromiseInterface
    {
        return $this->retrievePlatformShopAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlatformShopAsyncWithHttpInfo: プラットフォームショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrievePlatformShop'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformShopRetrievingResponse';
        $request = $this->retrievePlatformShopRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlatformShop'.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopRequest(mixed $id, string $contentType = self::contentTypes['retrievePlatformShop'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrievePlatformShop');
        }
        $resourcePath = '/v1/platforms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrievePlatformShopList: プラットフォームショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformShopListQueryParameter $query       プラットフォーム情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShopList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopList(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformShopList'][0]): mixed
    {
        list($response) = $this->retrievePlatformShopListWithHttpInfo($query, $contentType);

        return $response;
    }

    /**
     * retrievePlatformShopListWithHttpInfo: プラットフォームショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformShopListQueryParameter $query       プラットフォーム情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShopList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopListWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformShopList'][0]): array
    {
        $request = $this->retrievePlatformShopListRequest($query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrievePlatformShopListAsync: プラットフォームショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformShopListQueryParameter $query       プラットフォーム情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopListAsync(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformShopList'][0]): PromiseInterface
    {
        return $this->retrievePlatformShopListAsyncWithHttpInfo($query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrievePlatformShopListAsyncWithHttpInfo: プラットフォームショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformShopListQueryParameter $query       プラットフォーム情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopListAsyncWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformShopList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformShopListRetrievingResponse';
        $request = $this->retrievePlatformShopListRequest($query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrievePlatformShopList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrievePlatformShopListQueryParameter $query       プラットフォーム情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrievePlatformShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrievePlatformShopListRequest(mixed $query = null, string $contentType = self::contentTypes['retrievePlatformShopList'][0]): Request
    {
        $resourcePath = '/v1/platforms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveSubscription: サブスクリプション 取得.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscription(mixed $id, string $contentType = self::contentTypes['retrieveSubscription'][0]): mixed
    {
        list($response) = $this->retrieveSubscriptionWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * retrieveSubscriptionWithHttpInfo: サブスクリプション 取得.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrieveSubscription'][0]): array
    {
        $request = $this->retrieveSubscriptionRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveSubscriptionAsync: サブスクリプション 取得.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionAsync(mixed $id, string $contentType = self::contentTypes['retrieveSubscription'][0]): PromiseInterface
    {
        return $this->retrieveSubscriptionAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveSubscriptionAsyncWithHttpInfo: サブスクリプション 取得.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrieveSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionRetrievingResponse';
        $request = $this->retrieveSubscriptionRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveSubscription'.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionRequest(mixed $id, string $contentType = self::contentTypes['retrieveSubscription'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveSubscription');
        }
        $resourcePath = '/v1/subscriptions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveSubscriptionList: サブスクリプション 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionListQueryParameter $query       サブスクリプション情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionList(mixed $query, string $contentType = self::contentTypes['retrieveSubscriptionList'][0]): mixed
    {
        list($response) = $this->retrieveSubscriptionListWithHttpInfo($query, $contentType);

        return $response;
    }

    /**
     * retrieveSubscriptionListWithHttpInfo: サブスクリプション 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionListQueryParameter $query       サブスクリプション情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionListWithHttpInfo(mixed $query, string $contentType = self::contentTypes['retrieveSubscriptionList'][0]): array
    {
        $request = $this->retrieveSubscriptionListRequest($query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveSubscriptionListAsync: サブスクリプション 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionListQueryParameter $query       サブスクリプション情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionListAsync(mixed $query, string $contentType = self::contentTypes['retrieveSubscriptionList'][0]): PromiseInterface
    {
        return $this->retrieveSubscriptionListAsyncWithHttpInfo($query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveSubscriptionListAsyncWithHttpInfo: サブスクリプション 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionListQueryParameter $query       サブスクリプション情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionListAsyncWithHttpInfo(mixed $query, string $contentType = self::contentTypes['retrieveSubscriptionList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionListRetrievingResponse';
        $request = $this->retrieveSubscriptionListRequest($query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveSubscriptionList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionListQueryParameter $query       サブスクリプション情報の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                        $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionListRequest(mixed $query, string $contentType = self::contentTypes['retrieveSubscriptionList'][0]): Request
    {
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrieveSubscriptionList');
        }
        $resourcePath = '/v1/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveSubscriptionResultList: サブスクリプション結果 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionResultListQueryParameter $query       サブスクリプション結果の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                              $id          サブスクリプションID (required)
     * @param string                                                              $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionResultList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionResultList(mixed $query, mixed $id, string $contentType = self::contentTypes['retrieveSubscriptionResultList'][0]): mixed
    {
        list($response) = $this->retrieveSubscriptionResultListWithHttpInfo($query, $id, $contentType);

        return $response;
    }

    /**
     * retrieveSubscriptionResultListWithHttpInfo: サブスクリプション結果 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionResultListQueryParameter $query       サブスクリプション結果の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                              $id          サブスクリプションID (required)
     * @param string                                                              $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionResultList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionResultListWithHttpInfo(mixed $query, mixed $id, string $contentType = self::contentTypes['retrieveSubscriptionResultList'][0]): array
    {
        $request = $this->retrieveSubscriptionResultListRequest($query, $id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveSubscriptionResultListAsync: サブスクリプション結果 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionResultListQueryParameter $query       サブスクリプション結果の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                              $id          サブスクリプションID (required)
     * @param string                                                              $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionResultList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionResultListAsync(mixed $query, mixed $id, string $contentType = self::contentTypes['retrieveSubscriptionResultList'][0]): PromiseInterface
    {
        return $this->retrieveSubscriptionResultListAsyncWithHttpInfo($query, $id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveSubscriptionResultListAsyncWithHttpInfo: サブスクリプション結果 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionResultListQueryParameter $query       サブスクリプション結果の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                              $id          サブスクリプションID (required)
     * @param string                                                              $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionResultList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionResultListAsyncWithHttpInfo(mixed $query, mixed $id, string $contentType = self::contentTypes['retrieveSubscriptionResultList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionResultListRetrievingResponse';
        $request = $this->retrieveSubscriptionResultListRequest($query, $id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveSubscriptionResultList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveSubscriptionResultListQueryParameter $query       サブスクリプション結果の一覧取得において検索条件となるクエリパラメータ (required)
     * @param string                                                              $id          サブスクリプションID (required)
     * @param string                                                              $contentType The value for the Content-Type header. Check self::contentTypes['retrieveSubscriptionResultList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveSubscriptionResultListRequest(mixed $query, mixed $id, string $contentType = self::contentTypes['retrieveSubscriptionResultList'][0]): Request
    {
        // verify the required parameter 'query' is set
        if (null === $query || is_array($query) && 0 === count($query)) {
            throw new \InvalidArgumentException('Missing the required parameter $query when calling retrieveSubscriptionResultList');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveSubscriptionResultList');
        }
        $resourcePath = '/v1/subscriptions/{id}/result';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            true
        ) ?? []);
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveTenantContract: テナントショップ契約情報 取得.
     *
     * @param string $id           指定したテナントショップの契約情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの契約情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantContract'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ContractsRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantContract(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantContract'][0]): mixed
    {
        list($response) = $this->retrieveTenantContractWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveTenantContractWithHttpInfo: テナントショップ契約情報 取得.
     *
     * @param string $id           指定したテナントショップの契約情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの契約情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantContract'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ContractsRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantContractWithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantContract'][0]): array
    {
        $request = $this->retrieveTenantContractRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ContractsRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ContractsRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ContractsRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ContractsRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ContractsRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveTenantContractAsync: テナントショップ契約情報 取得.
     *
     * @param string $id           指定したテナントショップの契約情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの契約情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantContractAsync(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantContract'][0]): PromiseInterface
    {
        return $this->retrieveTenantContractAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveTenantContractAsyncWithHttpInfo: テナントショップ契約情報 取得.
     *
     * @param string $id           指定したテナントショップの契約情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの契約情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantContractAsyncWithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantContract'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ContractsRetrievingResponse';
        $request = $this->retrieveTenantContractRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveTenantContract'.
     *
     * @param string $id           指定したテナントショップの契約情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの契約情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantContract'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantContractRequest(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantContract'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveTenantContract');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling retrieveTenantContract');
        }
        $resourcePath = '/v1/contracts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveTenantExaminationInfo: （旧）テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfo'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function retrieveTenantExaminationInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfo'][0]): mixed
    {
        list($response) = $this->retrieveTenantExaminationInfoWithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveTenantExaminationInfoWithHttpInfo: （旧）テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfo'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function retrieveTenantExaminationInfoWithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfo'][0]): array
    {
        $request = $this->retrieveTenantExaminationInfoRequest($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveTenantExaminationInfoAsync: （旧）テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function retrieveTenantExaminationInfoAsync(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfo'][0]): PromiseInterface
    {
        return $this->retrieveTenantExaminationInfoAsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveTenantExaminationInfoAsyncWithHttpInfo: （旧）テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function retrieveTenantExaminationInfoAsyncWithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfo'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoRetrievingResponse';
        $request = $this->retrieveTenantExaminationInfoRequest($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveTenantExaminationInfo'.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function retrieveTenantExaminationInfoRequest(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfo'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveTenantExaminationInfo');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling retrieveTenantExaminationInfo');
        }
        $resourcePath = '/v1/contracts/examinations/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveTenantExaminationInfoV2: テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantExaminationInfoV2(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfoV2'][0]): mixed
    {
        list($response) = $this->retrieveTenantExaminationInfoV2WithHttpInfo($id, $tenantShopId, $contentType);

        return $response;
    }

    /**
     * retrieveTenantExaminationInfoV2WithHttpInfo: テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantExaminationInfoV2WithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfoV2'][0]): array
    {
        $request = $this->retrieveTenantExaminationInfoV2Request($id, $tenantShopId, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveTenantExaminationInfoV2Async: テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantExaminationInfoV2Async(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfoV2'][0]): PromiseInterface
    {
        return $this->retrieveTenantExaminationInfoV2AsyncWithHttpInfo($id, $tenantShopId, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveTenantExaminationInfoV2AsyncWithHttpInfo: テナントショップ本番環境申請情報 取得.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantExaminationInfoV2AsyncWithHttpInfo(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfoV2'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoV2RetrievingResponse';
        $request = $this->retrieveTenantExaminationInfoV2Request($id, $tenantShopId, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveTenantExaminationInfoV2'.
     *
     * @param string $id           指定したテナントショップの本番環境申請情報を取得します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を取得します。 (required)
     * @param string $contentType  The value for the Content-Type header. Check self::contentTypes['retrieveTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantExaminationInfoV2Request(mixed $id, mixed $tenantShopId, string $contentType = self::contentTypes['retrieveTenantExaminationInfoV2'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveTenantExaminationInfoV2');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling retrieveTenantExaminationInfoV2');
        }
        $resourcePath = '/v1/contracts/examinations_v2/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveTenantShop: テナントショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShop'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\TenantShopRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShop(mixed $id, string $contentType = self::contentTypes['retrieveTenantShop'][0]): mixed
    {
        list($response) = $this->retrieveTenantShopWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * retrieveTenantShopWithHttpInfo: テナントショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShop'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\TenantShopRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrieveTenantShop'][0]): array
    {
        $request = $this->retrieveTenantShopRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\TenantShopRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\TenantShopRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\TenantShopRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\TenantShopRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\TenantShopRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveTenantShopAsync: テナントショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopAsync(mixed $id, string $contentType = self::contentTypes['retrieveTenantShop'][0]): PromiseInterface
    {
        return $this->retrieveTenantShopAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveTenantShopAsyncWithHttpInfo: テナントショップ 取得.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['retrieveTenantShop'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\TenantShopRetrievingResponse';
        $request = $this->retrieveTenantShopRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveTenantShop'.
     *
     * @param string $id          ショップID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopRequest(mixed $id, string $contentType = self::contentTypes['retrieveTenantShop'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling retrieveTenantShop');
        }
        $resourcePath = '/v1/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * retrieveTenantShopList: テナントショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveTenantShopListQueryParameter $query       テナント情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                      $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShopList'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\TenantShopListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopList(mixed $query = null, string $contentType = self::contentTypes['retrieveTenantShopList'][0]): mixed
    {
        list($response) = $this->retrieveTenantShopListWithHttpInfo($query, $contentType);

        return $response;
    }

    /**
     * retrieveTenantShopListWithHttpInfo: テナントショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveTenantShopListQueryParameter $query       テナント情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                      $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShopList'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\TenantShopListRetrievingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopListWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrieveTenantShopList'][0]): array
    {
        $request = $this->retrieveTenantShopListRequest($query, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * retrieveTenantShopListAsync: テナントショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveTenantShopListQueryParameter $query       テナント情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                      $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopListAsync(mixed $query = null, string $contentType = self::contentTypes['retrieveTenantShopList'][0]): PromiseInterface
    {
        return $this->retrieveTenantShopListAsyncWithHttpInfo($query, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * retrieveTenantShopListAsyncWithHttpInfo: テナントショップ 一覧取得.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveTenantShopListQueryParameter $query       テナント情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                      $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopListAsyncWithHttpInfo(mixed $query = null, string $contentType = self::contentTypes['retrieveTenantShopList'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\TenantShopListRetrievingResponse';
        $request = $this->retrieveTenantShopListRequest($query, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'retrieveTenantShopList'.
     *
     * @param \OpenAPI\Fincode\Model\RetrieveTenantShopListQueryParameter $query       テナント情報の一覧取得において検索条件となるクエリパラメータ (optional)
     * @param string                                                      $contentType The value for the Content-Type header. Check self::contentTypes['retrieveTenantShopList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveTenantShopListRequest(mixed $query = null, string $contentType = self::contentTypes['retrieveTenantShopList'][0]): Request
    {
        $resourcePath = '/v1/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query',
            // param base name
            'PaginationQueryParams',
            // openApiType
            'form',
            // style
            true,
            // explode
            false
        ) ?? []);
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('GET', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * unsubscripbeSubscription: サブスクリプション 解約.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscripbeSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function unsubscripbeSubscription(mixed $id, string $contentType = self::contentTypes['unsubscripbeSubscription'][0]): mixed
    {
        list($response) = $this->unsubscripbeSubscriptionWithHttpInfo($id, $contentType);

        return $response;
    }

    /**
     * unsubscripbeSubscriptionWithHttpInfo: サブスクリプション 解約.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscripbeSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function unsubscripbeSubscriptionWithHttpInfo(mixed $id, string $contentType = self::contentTypes['unsubscripbeSubscription'][0]): array
    {
        $request = $this->unsubscripbeSubscriptionRequest($id, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * unsubscripbeSubscriptionAsync: サブスクリプション 解約.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscripbeSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function unsubscripbeSubscriptionAsync(mixed $id, string $contentType = self::contentTypes['unsubscripbeSubscription'][0]): PromiseInterface
    {
        return $this->unsubscripbeSubscriptionAsyncWithHttpInfo($id, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * unsubscripbeSubscriptionAsyncWithHttpInfo: サブスクリプション 解約.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscripbeSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function unsubscripbeSubscriptionAsyncWithHttpInfo(mixed $id, string $contentType = self::contentTypes['unsubscripbeSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionUnsubscribingResponse';
        $request = $this->unsubscripbeSubscriptionRequest($id, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'unsubscripbeSubscription'.
     *
     * @param string $id          サブスクリプションID (required)
     * @param string $contentType The value for the Content-Type header. Check self::contentTypes['unsubscripbeSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function unsubscripbeSubscriptionRequest(mixed $id, string $contentType = self::contentTypes['unsubscripbeSubscription'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling unsubscripbeSubscription');
        }
        $resourcePath = '/v1/subscriptions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('DELETE', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateCustomer: 顧客 更新.
     *
     * @param string                                         $id                      顧客ID (required)
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerUpdatingRequest $customerUpdatingRequest customerUpdatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['updateCustomer'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateCustomer(mixed $id, mixed $tenantShopId = null, mixed $customerUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomer'][0]): mixed
    {
        list($response) = $this->updateCustomerWithHttpInfo($id, $tenantShopId, $customerUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateCustomerWithHttpInfo: 顧客 更新.
     *
     * @param string                                         $id                      顧客ID (required)
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerUpdatingRequest $customerUpdatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['updateCustomer'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateCustomerWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $customerUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomer'][0]): array
    {
        $request = $this->updateCustomerRequest($id, $tenantShopId, $customerUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateCustomerAsync: 顧客 更新.
     *
     * @param string                                         $id                      顧客ID (required)
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerUpdatingRequest $customerUpdatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['updateCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerAsync(mixed $id, mixed $tenantShopId = null, mixed $customerUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomer'][0]): PromiseInterface
    {
        return $this->updateCustomerAsyncWithHttpInfo($id, $tenantShopId, $customerUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateCustomerAsyncWithHttpInfo: 顧客 更新.
     *
     * @param string                                         $id                      顧客ID (required)
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerUpdatingRequest $customerUpdatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['updateCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerAsyncWithHttpInfo(mixed $id, mixed $tenantShopId = null, mixed $customerUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomer'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerUpdatingResponse';
        $request = $this->updateCustomerRequest($id, $tenantShopId, $customerUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateCustomer'.
     *
     * @param string                                         $id                      顧客ID (required)
     * @param string                                         $tenantShopId            &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerUpdatingRequest $customerUpdatingRequest (optional)
     * @param string                                         $contentType             The value for the Content-Type header. Check self::contentTypes['updateCustomer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerRequest(mixed $id, mixed $tenantShopId = null, mixed $customerUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomer'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateCustomer');
        }
        $resourcePath = '/v1/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($customerUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customerUpdatingRequest));
            } else {
                $httpBody = $customerUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateCustomerCard: カード 更新.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $id                          更新するカードのID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardUpdatingRequest $customerCardUpdatingRequest customerCardUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateCustomerCard'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\CustomerCardUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateCustomerCard(mixed $customerId, mixed $id, mixed $tenantShopId = null, mixed $customerCardUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomerCard'][0]): mixed
    {
        list($response) = $this->updateCustomerCardWithHttpInfo($customerId, $id, $tenantShopId, $customerCardUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateCustomerCardWithHttpInfo: カード 更新.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $id                          更新するカードのID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardUpdatingRequest $customerCardUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateCustomerCard'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\CustomerCardUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateCustomerCardWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, mixed $customerCardUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomerCard'][0]): array
    {
        $request = $this->updateCustomerCardRequest($customerId, $id, $tenantShopId, $customerCardUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateCustomerCardAsync: カード 更新.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $id                          更新するカードのID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardUpdatingRequest $customerCardUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerCardAsync(mixed $customerId, mixed $id, mixed $tenantShopId = null, mixed $customerCardUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomerCard'][0]): PromiseInterface
    {
        return $this->updateCustomerCardAsyncWithHttpInfo($customerId, $id, $tenantShopId, $customerCardUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateCustomerCardAsyncWithHttpInfo: カード 更新.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $id                          更新するカードのID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardUpdatingRequest $customerCardUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerCardAsyncWithHttpInfo(mixed $customerId, mixed $id, mixed $tenantShopId = null, mixed $customerCardUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomerCard'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\CustomerCardUpdatingResponse';
        $request = $this->updateCustomerCardRequest($customerId, $id, $tenantShopId, $customerCardUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateCustomerCard'.
     *
     * @param string                                             $customerId                  このカードが紐づく顧客のID (required)
     * @param string                                             $id                          更新するカードのID (required)
     * @param string                                             $tenantShopId                &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ 顧客情報を共有しないプラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ このテナントショップに紐づく顧客のうち、指定したIDの顧客に対して登録されたカードの情報を更新します。 (optional)
     * @param \OpenAPI\Fincode\Model\CustomerCardUpdatingRequest $customerCardUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateCustomerCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateCustomerCardRequest(mixed $customerId, mixed $id, mixed $tenantShopId = null, mixed $customerCardUpdatingRequest = null, string $contentType = self::contentTypes['updateCustomerCard'][0]): Request
    {
        // verify the required parameter 'customerId' is set
        if (null === $customerId || is_array($customerId) && 0 === count($customerId)) {
            throw new \InvalidArgumentException('Missing the required parameter $customerId when calling updateCustomerCard');
        }
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateCustomerCard');
        }
        $resourcePath = '/v1/customers/{customer_id}/cards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $customerId) {
            $resourcePath = str_replace('{customer_id}', ObjectSerializer::toPathValue($customerId), $resourcePath);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($customerCardUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customerCardUpdatingRequest));
            } else {
                $httpBody = $customerCardUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updatePlan: プラン 更新.
     *
     * @param string                                     $id                  プランID (required)
     * @param \OpenAPI\Fincode\Model\PlanUpdatingRequest $planUpdatingRequest planUpdatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['updatePlan'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlanUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updatePlan(mixed $id, mixed $planUpdatingRequest = null, string $contentType = self::contentTypes['updatePlan'][0]): mixed
    {
        list($response) = $this->updatePlanWithHttpInfo($id, $planUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updatePlanWithHttpInfo: プラン 更新.
     *
     * @param string                                     $id                  プランID (required)
     * @param \OpenAPI\Fincode\Model\PlanUpdatingRequest $planUpdatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['updatePlan'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlanUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updatePlanWithHttpInfo(mixed $id, mixed $planUpdatingRequest = null, string $contentType = self::contentTypes['updatePlan'][0]): array
    {
        $request = $this->updatePlanRequest($id, $planUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlanUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlanUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlanUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlanUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlanUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updatePlanAsync: プラン 更新.
     *
     * @param string                                     $id                  プランID (required)
     * @param \OpenAPI\Fincode\Model\PlanUpdatingRequest $planUpdatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['updatePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlanAsync(mixed $id, mixed $planUpdatingRequest = null, string $contentType = self::contentTypes['updatePlan'][0]): PromiseInterface
    {
        return $this->updatePlanAsyncWithHttpInfo($id, $planUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updatePlanAsyncWithHttpInfo: プラン 更新.
     *
     * @param string                                     $id                  プランID (required)
     * @param \OpenAPI\Fincode\Model\PlanUpdatingRequest $planUpdatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['updatePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlanAsyncWithHttpInfo(mixed $id, mixed $planUpdatingRequest = null, string $contentType = self::contentTypes['updatePlan'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlanUpdatingResponse';
        $request = $this->updatePlanRequest($id, $planUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updatePlan'.
     *
     * @param string                                     $id                  プランID (required)
     * @param \OpenAPI\Fincode\Model\PlanUpdatingRequest $planUpdatingRequest (optional)
     * @param string                                     $contentType         The value for the Content-Type header. Check self::contentTypes['updatePlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlanRequest(mixed $id, mixed $planUpdatingRequest = null, string $contentType = self::contentTypes['updatePlan'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updatePlan');
        }
        $resourcePath = '/v1/plans/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($planUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($planUpdatingRequest));
            } else {
                $httpBody = $planUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updatePlatformShop: プラットフォームショップ 更新.
     *
     * @param string                                             $id                          ショップID (required)
     * @param \OpenAPI\Fincode\Model\PlatformShopUpdatingRequest $platformShopUpdatingRequest platformShopUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updatePlatformShop'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\PlatformShopUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updatePlatformShop(mixed $id, mixed $platformShopUpdatingRequest = null, string $contentType = self::contentTypes['updatePlatformShop'][0]): mixed
    {
        list($response) = $this->updatePlatformShopWithHttpInfo($id, $platformShopUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updatePlatformShopWithHttpInfo: プラットフォームショップ 更新.
     *
     * @param string                                             $id                          ショップID (required)
     * @param \OpenAPI\Fincode\Model\PlatformShopUpdatingRequest $platformShopUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updatePlatformShop'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\PlatformShopUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updatePlatformShopWithHttpInfo(mixed $id, mixed $platformShopUpdatingRequest = null, string $contentType = self::contentTypes['updatePlatformShop'][0]): array
    {
        $request = $this->updatePlatformShopRequest($id, $platformShopUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updatePlatformShopAsync: プラットフォームショップ 更新.
     *
     * @param string                                             $id                          ショップID (required)
     * @param \OpenAPI\Fincode\Model\PlatformShopUpdatingRequest $platformShopUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updatePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlatformShopAsync(mixed $id, mixed $platformShopUpdatingRequest = null, string $contentType = self::contentTypes['updatePlatformShop'][0]): PromiseInterface
    {
        return $this->updatePlatformShopAsyncWithHttpInfo($id, $platformShopUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updatePlatformShopAsyncWithHttpInfo: プラットフォームショップ 更新.
     *
     * @param string                                             $id                          ショップID (required)
     * @param \OpenAPI\Fincode\Model\PlatformShopUpdatingRequest $platformShopUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updatePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlatformShopAsyncWithHttpInfo(mixed $id, mixed $platformShopUpdatingRequest = null, string $contentType = self::contentTypes['updatePlatformShop'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\PlatformShopUpdatingResponse';
        $request = $this->updatePlatformShopRequest($id, $platformShopUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updatePlatformShop'.
     *
     * @param string                                             $id                          ショップID (required)
     * @param \OpenAPI\Fincode\Model\PlatformShopUpdatingRequest $platformShopUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updatePlatformShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updatePlatformShopRequest(mixed $id, mixed $platformShopUpdatingRequest = null, string $contentType = self::contentTypes['updatePlatformShop'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updatePlatformShop');
        }
        $resourcePath = '/v1/platforms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($platformShopUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($platformShopUpdatingRequest));
            } else {
                $httpBody = $platformShopUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateSubscription: サブスクリプション 更新.
     *
     * @param string                                             $id                          サブスクリプションID (required)
     * @param \OpenAPI\Fincode\Model\SubscriptionUpdatingRequest $subscriptionUpdatingRequest subscriptionUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\SubscriptionUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateSubscription(mixed $id, mixed $subscriptionUpdatingRequest = null, string $contentType = self::contentTypes['updateSubscription'][0]): mixed
    {
        list($response) = $this->updateSubscriptionWithHttpInfo($id, $subscriptionUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateSubscriptionWithHttpInfo: サブスクリプション 更新.
     *
     * @param string                                             $id                          サブスクリプションID (required)
     * @param \OpenAPI\Fincode\Model\SubscriptionUpdatingRequest $subscriptionUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\SubscriptionUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateSubscriptionWithHttpInfo(mixed $id, mixed $subscriptionUpdatingRequest = null, string $contentType = self::contentTypes['updateSubscription'][0]): array
    {
        $request = $this->updateSubscriptionRequest($id, $subscriptionUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateSubscriptionAsync: サブスクリプション 更新.
     *
     * @param string                                             $id                          サブスクリプションID (required)
     * @param \OpenAPI\Fincode\Model\SubscriptionUpdatingRequest $subscriptionUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateSubscriptionAsync(mixed $id, mixed $subscriptionUpdatingRequest = null, string $contentType = self::contentTypes['updateSubscription'][0]): PromiseInterface
    {
        return $this->updateSubscriptionAsyncWithHttpInfo($id, $subscriptionUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateSubscriptionAsyncWithHttpInfo: サブスクリプション 更新.
     *
     * @param string                                             $id                          サブスクリプションID (required)
     * @param \OpenAPI\Fincode\Model\SubscriptionUpdatingRequest $subscriptionUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateSubscriptionAsyncWithHttpInfo(mixed $id, mixed $subscriptionUpdatingRequest = null, string $contentType = self::contentTypes['updateSubscription'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\SubscriptionUpdatingResponse';
        $request = $this->updateSubscriptionRequest($id, $subscriptionUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateSubscription'.
     *
     * @param string                                             $id                          サブスクリプションID (required)
     * @param \OpenAPI\Fincode\Model\SubscriptionUpdatingRequest $subscriptionUpdatingRequest (optional)
     * @param string                                             $contentType                 The value for the Content-Type header. Check self::contentTypes['updateSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateSubscriptionRequest(mixed $id, mixed $subscriptionUpdatingRequest = null, string $contentType = self::contentTypes['updateSubscription'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateSubscription');
        }
        $resourcePath = '/v1/subscriptions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($subscriptionUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscriptionUpdatingRequest));
            } else {
                $httpBody = $subscriptionUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateTenantExaminationInfo: （旧）テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                $id                             指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                $tenantShopId                   &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoUpdatingRequest $examinationInfoUpdatingRequest examinationInfoUpdatingRequest (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfo'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function updateTenantExaminationInfo(mixed $id, mixed $tenantShopId, mixed $examinationInfoUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfo'][0]): mixed
    {
        list($response) = $this->updateTenantExaminationInfoWithHttpInfo($id, $tenantShopId, $examinationInfoUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateTenantExaminationInfoWithHttpInfo: （旧）テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                $id                             指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                $tenantShopId                   &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoUpdatingRequest $examinationInfoUpdatingRequest (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfo'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function updateTenantExaminationInfoWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $examinationInfoUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfo'][0]): array
    {
        $request = $this->updateTenantExaminationInfoRequest($id, $tenantShopId, $examinationInfoUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateTenantExaminationInfoAsync: （旧）テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                $id                             指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                $tenantShopId                   &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoUpdatingRequest $examinationInfoUpdatingRequest (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function updateTenantExaminationInfoAsync(mixed $id, mixed $tenantShopId, mixed $examinationInfoUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfo'][0]): PromiseInterface
    {
        return $this->updateTenantExaminationInfoAsyncWithHttpInfo($id, $tenantShopId, $examinationInfoUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateTenantExaminationInfoAsyncWithHttpInfo: （旧）テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                $id                             指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                $tenantShopId                   &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoUpdatingRequest $examinationInfoUpdatingRequest (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function updateTenantExaminationInfoAsyncWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $examinationInfoUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfo'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoUpdatingResponse';
        $request = $this->updateTenantExaminationInfoRequest($id, $tenantShopId, $examinationInfoUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateTenantExaminationInfo'.
     *
     * @param string                                                $id                             指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                $tenantShopId                   &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoUpdatingRequest $examinationInfoUpdatingRequest (optional)
     * @param string                                                $contentType                    The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     *
     * @deprecated
     */
    public function updateTenantExaminationInfoRequest(mixed $id, mixed $tenantShopId, mixed $examinationInfoUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfo'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateTenantExaminationInfo');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling updateTenantExaminationInfo');
        }
        $resourcePath = '/v1/contracts/examinations/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($examinationInfoUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($examinationInfoUpdatingRequest));
            } else {
                $httpBody = $examinationInfoUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateTenantExaminationInfoV2: テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                  $id                               指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                  $tenantShopId                     &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingRequest $examinationInfoV2UpdatingRequest examinationInfoV2UpdatingRequest (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateTenantExaminationInfoV2(mixed $id, mixed $tenantShopId, mixed $examinationInfoV2UpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfoV2'][0]): mixed
    {
        list($response) = $this->updateTenantExaminationInfoV2WithHttpInfo($id, $tenantShopId, $examinationInfoV2UpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateTenantExaminationInfoV2WithHttpInfo: テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                  $id                               指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                  $tenantShopId                     &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingRequest $examinationInfoV2UpdatingRequest (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateTenantExaminationInfoV2WithHttpInfo(mixed $id, mixed $tenantShopId, mixed $examinationInfoV2UpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfoV2'][0]): array
    {
        $request = $this->updateTenantExaminationInfoV2Request($id, $tenantShopId, $examinationInfoV2UpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateTenantExaminationInfoV2Async: テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                  $id                               指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                  $tenantShopId                     &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingRequest $examinationInfoV2UpdatingRequest (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantExaminationInfoV2Async(mixed $id, mixed $tenantShopId, mixed $examinationInfoV2UpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfoV2'][0]): PromiseInterface
    {
        return $this->updateTenantExaminationInfoV2AsyncWithHttpInfo($id, $tenantShopId, $examinationInfoV2UpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateTenantExaminationInfoV2AsyncWithHttpInfo: テナントショップ本番環境申請情報 更新.
     *
     * @param string                                                  $id                               指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                  $tenantShopId                     &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingRequest $examinationInfoV2UpdatingRequest (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantExaminationInfoV2AsyncWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $examinationInfoV2UpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfoV2'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingResponse';
        $request = $this->updateTenantExaminationInfoV2Request($id, $tenantShopId, $examinationInfoV2UpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateTenantExaminationInfoV2'.
     *
     * @param string                                                  $id                               指定したテナントショップの本番環境申請情報を更新します。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                                  $tenantShopId                     &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップの本番環境申請情報を更新します。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationInfoV2UpdatingRequest $examinationInfoV2UpdatingRequest (optional)
     * @param string                                                  $contentType                      The value for the Content-Type header. Check self::contentTypes['updateTenantExaminationInfoV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantExaminationInfoV2Request(mixed $id, mixed $tenantShopId, mixed $examinationInfoV2UpdatingRequest = null, string $contentType = self::contentTypes['updateTenantExaminationInfoV2'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateTenantExaminationInfoV2');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling updateTenantExaminationInfoV2');
        }
        $resourcePath = '/v1/contracts/examinations_v2/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($examinationInfoV2UpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($examinationInfoV2UpdatingRequest));
            } else {
                $httpBody = $examinationInfoV2UpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * updateTenantShop: テナントショップ 更新.
     *
     * @param string                                           $id                        ショップID (required)
     * @param \OpenAPI\Fincode\Model\TenantShopUpdatingRequest $tenantShopUpdatingRequest tenantShopUpdatingRequest (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['updateTenantShop'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\TenantShopUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateTenantShop(mixed $id, mixed $tenantShopUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantShop'][0]): mixed
    {
        list($response) = $this->updateTenantShopWithHttpInfo($id, $tenantShopUpdatingRequest, $contentType);

        return $response;
    }

    /**
     * updateTenantShopWithHttpInfo: テナントショップ 更新.
     *
     * @param string                                           $id                        ショップID (required)
     * @param \OpenAPI\Fincode\Model\TenantShopUpdatingRequest $tenantShopUpdatingRequest (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['updateTenantShop'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\TenantShopUpdatingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function updateTenantShopWithHttpInfo(mixed $id, mixed $tenantShopUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantShop'][0]): array
    {
        $request = $this->updateTenantShopRequest($id, $tenantShopUpdatingRequest, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\TenantShopUpdatingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\TenantShopUpdatingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\TenantShopUpdatingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\TenantShopUpdatingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\TenantShopUpdatingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * updateTenantShopAsync: テナントショップ 更新.
     *
     * @param string                                           $id                        ショップID (required)
     * @param \OpenAPI\Fincode\Model\TenantShopUpdatingRequest $tenantShopUpdatingRequest (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['updateTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantShopAsync(mixed $id, mixed $tenantShopUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantShop'][0]): PromiseInterface
    {
        return $this->updateTenantShopAsyncWithHttpInfo($id, $tenantShopUpdatingRequest, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * updateTenantShopAsyncWithHttpInfo: テナントショップ 更新.
     *
     * @param string                                           $id                        ショップID (required)
     * @param \OpenAPI\Fincode\Model\TenantShopUpdatingRequest $tenantShopUpdatingRequest (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['updateTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantShopAsyncWithHttpInfo(mixed $id, mixed $tenantShopUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantShop'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\TenantShopUpdatingResponse';
        $request = $this->updateTenantShopRequest($id, $tenantShopUpdatingRequest, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'updateTenantShop'.
     *
     * @param string                                           $id                        ショップID (required)
     * @param \OpenAPI\Fincode\Model\TenantShopUpdatingRequest $tenantShopUpdatingRequest (optional)
     * @param string                                           $contentType               The value for the Content-Type header. Check self::contentTypes['updateTenantShop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function updateTenantShopRequest(mixed $id, mixed $tenantShopUpdatingRequest = null, string $contentType = self::contentTypes['updateTenantShop'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateTenantShop');
        }
        $resourcePath = '/v1/tenants/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (isset($tenantShopUpdatingRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tenantShopUpdatingRequest));
            } else {
                $httpBody = $tenantShopUpdatingRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('PUT', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * uploadExaminationFile: テナントショップ 審査ファイルアップロード.
     *
     * @param string                                     $id           指定したテナントショップのものとしてファイルをアップロードします。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                     $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationFileType $type         type (required)
     * @param mixed                                      $data         審査ファイルデータ\\\\ \\\\ 画像ファイルをマルチパートアップロードするときはこの&#x60;data&#x60;フィールドに画像データを設定します。 (required)
     * @param string                                     $contentType  The value for the Content-Type header. Check self::contentTypes['uploadExaminationFile'] to see the possible values for this operation
     *
     * @return \OpenAPI\Fincode\Model\ExaminationFileUploadingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function uploadExaminationFile(mixed $id, mixed $tenantShopId, mixed $type, mixed $data, string $contentType = self::contentTypes['uploadExaminationFile'][0]): mixed
    {
        list($response) = $this->uploadExaminationFileWithHttpInfo($id, $tenantShopId, $type, $data, $contentType);

        return $response;
    }

    /**
     * uploadExaminationFileWithHttpInfo: テナントショップ 審査ファイルアップロード.
     *
     * @param string                                     $id           指定したテナントショップのものとしてファイルをアップロードします。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                     $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationFileType $type         (required)
     * @param mixed                                      $data         審査ファイルデータ\\\\ \\\\ 画像ファイルをマルチパートアップロードするときはこの&#x60;data&#x60;フィールドに画像データを設定します。 (required)
     * @param string                                     $contentType  The value for the Content-Type header. Check self::contentTypes['uploadExaminationFile'] to see the possible values for this operation
     *
     * @return array{
     *     \OpenAPI\Fincode\Model\ExaminationFileUploadingResponse|\OpenAPI\Fincode\Model\FincodeAPIErrorResponse,
     *     int,
     *     list<string>,
     * } Array of response body, status, and response headers
     *
     * @throws ApiException              on non-2xx response
     * @throws GuzzleException
     * @throws \InvalidArgumentException
     */
    public function uploadExaminationFileWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $type, mixed $data, string $contentType = self::contentTypes['uploadExaminationFile'][0]): array
    {
        $request = $this->uploadExaminationFileRequest($id, $tenantShopId, $type, $data, $contentType);
        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }
            $statusCode = $response->getStatusCode();
            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }
            switch ($statusCode) {
                case 200:
                    if ('\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse', []), $response->getStatusCode(), $response->getHeaders()];
                case 400:
                    if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody();
                    // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Fincode\Model\FincodeAPIErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [ObjectSerializer::deserialize($content, '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', []), $response->getStatusCode(), $response->getHeaders()];
            }
            $returnType = '\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse';
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\OpenAPI\Fincode\Model\FincodeAPIErrorResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * uploadExaminationFileAsync: テナントショップ 審査ファイルアップロード.
     *
     * @param string                                     $id           指定したテナントショップのものとしてファイルをアップロードします。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                     $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationFileType $type         (required)
     * @param mixed                                      $data         審査ファイルデータ\\\\ \\\\ 画像ファイルをマルチパートアップロードするときはこの&#x60;data&#x60;フィールドに画像データを設定します。 (required)
     * @param string                                     $contentType  The value for the Content-Type header. Check self::contentTypes['uploadExaminationFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function uploadExaminationFileAsync(mixed $id, mixed $tenantShopId, mixed $type, mixed $data, string $contentType = self::contentTypes['uploadExaminationFile'][0]): PromiseInterface
    {
        return $this->uploadExaminationFileAsyncWithHttpInfo($id, $tenantShopId, $type, $data, $contentType)->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * uploadExaminationFileAsyncWithHttpInfo: テナントショップ 審査ファイルアップロード.
     *
     * @param string                                     $id           指定したテナントショップのものとしてファイルをアップロードします。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                     $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationFileType $type         (required)
     * @param mixed                                      $data         審査ファイルデータ\\\\ \\\\ 画像ファイルをマルチパートアップロードするときはこの&#x60;data&#x60;フィールドに画像データを設定します。 (required)
     * @param string                                     $contentType  The value for the Content-Type header. Check self::contentTypes['uploadExaminationFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function uploadExaminationFileAsyncWithHttpInfo(mixed $id, mixed $tenantShopId, mixed $type, mixed $data, string $contentType = self::contentTypes['uploadExaminationFile'][0]): PromiseInterface
    {
        $returnType = '\OpenAPI\Fincode\Model\ExaminationFileUploadingResponse';
        $request = $this->uploadExaminationFileRequest($id, $tenantShopId, $type, $data, $contentType);

        return $this->client->sendAsync($request, $this->createHttpClientOption())->then(function ($response) use ($returnType) {
            if ('\SplFileObject' === $returnType) {
                $content = $response->getBody();
            // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('string' !== $returnType) {
                    $content = json_decode($content);
                }
            }

            return [ObjectSerializer::deserialize($content, $returnType, []), $response->getStatusCode(), $response->getHeaders()];
        }, function ($exception) {
            $response = $exception->getResponse();
            $statusCode = $response->getStatusCode();
            throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
        });
    }

    /**
     * Create request for operation 'uploadExaminationFile'.
     *
     * @param string                                     $id           指定したテナントショップのものとしてファイルをアップロードします。&#x60;Tenant-\OpenAPI\Fincode\Model\Shop-Id&#x60;ヘッダーも併せて指定してください。 (required)
     * @param string                                     $tenantShopId &lt;span class&#x3D;\&quot;smallText color--red-400\&quot;&gt;※ プラットフォームのメインショップのみ指定可&lt;/span&gt;\\ テナントショップID。\\ 指定したテナントショップのものとしてファイルをアップロードします。 (required)
     * @param \OpenAPI\Fincode\Model\ExaminationFileType $type         (required)
     * @param mixed                                      $data         審査ファイルデータ\\\\ \\\\ 画像ファイルをマルチパートアップロードするときはこの&#x60;data&#x60;フィールドに画像データを設定します。 (required)
     * @param string                                     $contentType  The value for the Content-Type header. Check self::contentTypes['uploadExaminationFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     */
    public function uploadExaminationFileRequest(mixed $id, mixed $tenantShopId, mixed $type, mixed $data, string $contentType = self::contentTypes['uploadExaminationFile'][0]): Request
    {
        // verify the required parameter 'id' is set
        if (null === $id || is_array($id) && 0 === count($id)) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling uploadExaminationFile');
        }
        // verify the required parameter 'tenantShopId' is set
        if (null === $tenantShopId || is_array($tenantShopId) && 0 === count($tenantShopId)) {
            throw new \InvalidArgumentException('Missing the required parameter $tenantShopId when calling uploadExaminationFile');
        }
        // verify the required parameter 'type' is set
        if (null === $type || is_array($type) && 0 === count($type)) {
            throw new \InvalidArgumentException('Missing the required parameter $type when calling uploadExaminationFile');
        }
        // verify the required parameter 'data' is set
        if (null === $data || is_array($data) && 0 === count($data)) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling uploadExaminationFile');
        }
        $resourcePath = '/v1/contracts/examinations/tenants/{id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        // header params
        if (null !== $tenantShopId) {
            $headerParams['Tenant-Shop-Id'] = ObjectSerializer::toHeaderValue($tenantShopId);
        }
        // path params
        if (null !== $id) {
            $resourcePath = str_replace('{id}', ObjectSerializer::toPathValue($id), $resourcePath);
        }
        // form params
        if (null !== $type) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if (null !== $data) {
            $formParams['data'] = ObjectSerializer::toFormValue($data);
        }
        $headers = $this->headerSelector->selectHeaders(['application/json'], $contentType, $multipart);
        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = ['name' => $formParamName, 'contents' => $formParamValueItem];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !empty($this->config->getPassword())) {
            $headers['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().':'.$this->config->getPassword());
        }
        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge($defaultHeaders, $headerParams, $headers);
        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request('POST', $operationHost.$resourcePath.($query ? "?{$query}" : ''), $headers, $httpBody);
    }

    /**
     * Create http client option.
     *
     * @return array of http client options
     *
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
